<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Translation Testing Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="config.js" onerror="console.log('config.js not found, using inline config')"></script>
    <script src="metrics.js" onerror="console.log('metrics.js not found, using inline metrics')"></script>
    <script src="api.js" onerror="console.log('api.js not found, using inline API')"></script>
    <script src="utils.js" onerror="console.log('utils.js not found, using inline utils')"></script>
    <script src="synonyms.js" onerror="console.log('Using built-in synonyms dictionary')"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function App() {
          const [mode, setMode] = useState('manual');
          const [sourceText, setSourceText] = useState('');
          const [sourceLang, setSourceLang] = useState('en');
          const [targetLang, setTargetLang] = useState('de');
          const [translations, setTranslations] = useState([]);
          const [isTranslating, setIsTranslating] = useState(false);
          const shouldStopRef = React.useRef(false);
          const [systemPrompt, setSystemPrompt] = useState('You are a professional translator. Provide ONLY the translation, no explanations or commentary.');
          const [styleInstructions, setStyleInstructions] = useState('Output ONLY the translated text. Do not add explanations, notes, alternatives, or meta-commentary about the translation.');
          
          const [testData, setTestData] = useState([]);
          const [testDataFull, setTestDataFull] = useState([]); // Full loaded data
          const [testResults, setTestResults] = useState([]);
          const [isLoadingTests, setIsLoadingTests] = useState(false);
          const [selectedTestFile, setSelectedTestFile] = useState(null);
          const [testSourceLang, setTestSourceLang] = useState('en');
          const [testTargetLang, setTestTargetLang] = useState('de');
          const [testLimit, setTestLimit] = useState(100); // Max tests to run
          const [testStartFrom, setTestStartFrom] = useState(0); // Start index
          const [testSelection, setTestSelection] = useState('first'); // 'first', 'random', 'range'
          const [testFileFormat, setTestFileFormat] = useState('single'); // 'single' (TMX/JSON) or 'opus-pair'
          
          // Evaluation states
          const [evalData, setEvalData] = useState([]);
          const [evalResults, setEvalResults] = useState([]);
          const [isEvaluating, setIsEvaluating] = useState(false);
          const [selectedEvalFile, setSelectedEvalFile] = useState(null);
          const [evaluatorModel, setEvaluatorModel] = useState('deepseek-chat');
          const [evaluatorApiKey, setEvaluatorApiKey] = useState('');
          const [evalWarning, setEvalWarning] = useState('');
          
          // Evaluation methods selection
          const [evalMethods, setEvalMethods] = useState({
            // Reference-based methods
            bleu: true,
            meteor: true,
            cer: true,
            wer: true,
            jaccard: true,
            chrf: true,
            lengthRatio: true,
            // Neural metrics (require Python backend)
            bertScore: true,
            comet: true,
            bleurt: true, // Google's BLEURT metric
            cometQE: true, // No-reference COMET
            // No-reference methods (work without gold translation)
            repetition: true,
            numberPres: true,
            copyRate: true,
            sentenceCount: true,
            llmJudge: true,
            basicMetrics: true
          });
          
          // Metric weights for Total Score calculation (reference-based)
          // Balanced for comprehensive quality assessment
          const [metricWeights, setMetricWeights] = useState({
            bleu: 10,        // N-gram precision - classic metric
            meteor: 10,      // Synonyms & stemming aware
            cer: 5,          // Character-level errors (lower weight - often noisy)
            wer: 5,          // Word-level errors
            jaccard: 5,      // Word overlap
            chrf: 10,        // Character n-gram F-score - good for morphologically rich langs
            lengthRatio: 5,  // Length similarity
            bertScore: 20,   // Semantic similarity - high weight (neural)
            comet: 15,       // State-of-art MT metric (neural)
            bleurt: 15       // BERT-based learned metric (neural)
          });
          
          // Metric weights for No-Reference Total Score
          const [noRefWeights, setNoRefWeights] = useState({
            repetition: 10,
            numberPres: 15,
            copyRate: 10,
            lengthRatio: 5,
            llmScore: 30, // LLM overall score (if enabled)
            cometQE: 30 // COMET-QE (if enabled)
          });
          
          // Python backend URL (Flask server for BERTScore/COMET)
          const [pythonBackendUrl, setPythonBackendUrl] = useState('http://localhost:5000');
          
          // Metric descriptions for tooltips
          const metricDescriptions = {
            bleu: "BLEU (Bilingual Evaluation Understudy) - Measures n-gram precision between translation and reference. Higher is better. Excellent: >60, Good: >40, Fair: >20",
            meteor: "METEOR (Metric for Evaluation of Translation with Explicit ORdering) - Considers synonyms, stemming, and word order. Higher is better. Excellent: >50, Good: >30",
            cer: "CER (Character Error Rate) - Edit distance at character level. Lower is better. Excellent: <10%, Good: <20%, Fair: <30%",
            wer: "WER (Word Error Rate) - Edit distance at word level. Lower is better. Excellent: <15%, Good: <25%, Fair: <35%",
            jaccard: "Jaccard Similarity - Overlap coefficient between word sets. Higher is better. Excellent: >70, Good: >50",
            chrf: "chrF (Character F-score) - F-score based on character n-grams. Higher is better. Excellent: >70, Good: >50",
            lengthRatio: "Length Ratio - Translation length vs reference length. Ideal: 90-110%. Too low may mean missing content, too high may indicate verbosity",
            total: "Total Score - Weighted combination of all metrics. Weights can be configured in settings. Higher is better.",
            // Neural metrics
            bertScore: "BERTScore - Semantic similarity using BERT embeddings. Higher is better. Excellent: >90, Good: >80",
            comet: "COMET - Neural MT evaluation metric. Higher is better. Excellent: >0.85, Good: >0.75",
            bleurt: "BLEURT - Google's learned evaluation metric trained on human judgments. Higher is better. Excellent: >0.7, Good: >0.5",
            cometQE: "COMET-QE - Quality Estimation without reference. Higher is better. Excellent: >0.3, Good: >0.2, Fair: >0",
            // No-reference metrics
            repetition: "Repetition Ratio - % of repeated bigrams. High values (>20%) may indicate LLM hallucinations or loops. Lower is better.",
            numberPres: "Number Preservation - % of numbers from original preserved in translation. 100% is ideal.",
            copyRate: "Copy Rate - % of words copied directly from source. High values (>30%) may indicate untranslated content. Context-dependent.",
            sentenceCount: "Sentence Alignment - Whether sentence count matches between original and translation. Should match.",
            // LLM metrics
            fluency: "LLM Fluency Score - How natural and grammatically correct the translation reads (1-10)",
            adequacy: "LLM Adequacy Score - How well the meaning is preserved from the original (1-10)",
            score: "LLM Overall Score - Combined quality assessment by LLM judge (1-10)"
          };
          
          const [apiKeys, setApiKeys] = useState({
            anthropic: '',
            openai: '',
            deepseek: '',
            deepl: '',
            google: ''
          });

          const languages = [
            { code: 'en', name: 'English' },
            { code: 'ru', name: '–†—É—Å—Å–∫–∏–π' },
            { code: 'de', name: 'Deutsch' },
            { code: 'fr', name: 'Fran√ßais' },
            { code: 'es', name: 'Espa√±ol' },
            { code: 'it', name: 'Italiano' },
            { code: 'pt', name: 'Portugu√™s' },
            { code: 'zh', name: '‰∏≠Êñá' },
            { code: 'ja', name: 'Êó•Êú¨Ë™û' },
            { code: 'ko', name: 'ÌïúÍµ≠Ïñ¥' }
          ];

          const availableModels = [
            // Anthropic Claude
            { id: 'claude-opus-4.5', name: 'Claude Opus 4.5', provider: 'anthropic', model: 'claude-opus-4-5-20251101', supportsPrompts: true, cost: 'high' },
            { id: 'claude-sonnet-4.5', name: 'Claude Sonnet 4.5', provider: 'anthropic', model: 'claude-sonnet-4-5-20250929', supportsPrompts: true, cost: 'medium' },
            { id: 'claude-haiku-4.5', name: 'Claude Haiku 4.5', provider: 'anthropic', model: 'claude-haiku-4-5-20251001', supportsPrompts: true, cost: 'low' },
            { id: 'claude-sonnet-4', name: 'Claude Sonnet 4', provider: 'anthropic', model: 'claude-sonnet-4-20250514', supportsPrompts: true, cost: 'medium' },

            
            { id: 'gpt-4o', name: 'GPT-4o', provider: 'openai', model: 'gpt-4o', supportsPrompts: true, cost: 'medium' },
            { id: 'gpt-4o-mini', name: 'GPT-4o Mini', provider: 'openai', model: 'gpt-4o-mini', supportsPrompts: true, cost: 'low' },
            // OpenAI GPT Legacy (older models for comparison)
            { id: 'gpt-4-turbo', name: 'GPT-4 Turbo', provider: 'openai', model: 'gpt-4-turbo', supportsPrompts: true, cost: 'medium' },
            { id: 'gpt-4', name: 'GPT-4', provider: 'openai', model: 'gpt-4', supportsPrompts: true, cost: 'high' },
            { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo', provider: 'openai', model: 'gpt-3.5-turbo', supportsPrompts: true, cost: 'very-low' },
            
            // DeepSeek
            { id: 'deepseek-chat', name: 'DeepSeek Chat', provider: 'deepseek', model: 'deepseek-chat', supportsPrompts: true, cost: 'very-low' },
            
            { id: 'deepl', name: 'DeepL', provider: 'deepl', model: 'deepl', supportsPrompts: false, cost: 'low' },
            { id: 'google', name: 'Google Translate', provider: 'google', model: 'google-translate', supportsPrompts: false, cost: 'low' },
            
            // LOCAL MODELS (no API key required)
            { id: 'argos', name: 'üñ•Ô∏è Argos Translate', provider: 'argos', model: 'argos', supportsPrompts: false, cost: 'free', local: true },
            { id: 'nllb-200-600m', name: 'üñ•Ô∏è NLLB-200 600M (Meta)', provider: 'nllb', model: 'nllb-200-600m', supportsPrompts: false, cost: 'free', local: true },
            { id: 'nllb-200-1.3b', name: 'üñ•Ô∏è NLLB-200 1.3B (Meta)', provider: 'nllb', model: 'nllb-200-1.3b', supportsPrompts: false, cost: 'free', local: true },
            { id: 'nllb-200-3.3b', name: 'üñ•Ô∏è NLLB-200 3.3B (Meta)', provider: 'nllb', model: 'nllb-200-3.3b', supportsPrompts: false, cost: 'free', local: true },
            { id: 'opus-mt', name: 'üñ•Ô∏è OPUS-MT (Helsinki)', provider: 'opus', model: 'opus-mt', supportsPrompts: false, cost: 'free', local: true }
          ];
          
          // Model metadata: release dates, pricing per 1M tokens, company info, model size
          // Prices as of January 2026 (output tokens price)
          // sizeB = model size in billions of parameters (estimates for proprietary models)
          const modelMetadata = {
            // Anthropic Claude Current (https://www.anthropic.com/pricing)
            // Sizes are estimates based on pricing/performance tiers
            'Claude Opus 4.5': { released: '2025-11-01', priceIn: 15.00, priceOut: 75.00, company: 'Anthropic', type: 'LLM', sizeB: 500 },
            'Claude Sonnet 4.5': { released: '2025-09-29', priceIn: 3.00, priceOut: 15.00, company: 'Anthropic', type: 'LLM', sizeB: 100 },
            'Claude Haiku 4.5': { released: '2025-10-01', priceIn: 0.80, priceOut: 4.00, company: 'Anthropic', type: 'LLM', sizeB: 20 },
            'Claude Sonnet 4': { released: '2025-05-14', priceIn: 3.00, priceOut: 15.00, company: 'Anthropic', type: 'LLM', sizeB: 100 },
            'claude-opus-4-5-20251101': { released: '2025-11-01', priceIn: 15.00, priceOut: 75.00, company: 'Anthropic', type: 'LLM', sizeB: 500 },
            'claude-sonnet-4-5-20250929': { released: '2025-09-29', priceIn: 3.00, priceOut: 15.00, company: 'Anthropic', type: 'LLM', sizeB: 100 },
            'claude-haiku-4-5-20251001': { released: '2025-10-01', priceIn: 0.80, priceOut: 4.00, company: 'Anthropic', type: 'LLM', sizeB: 20 },
            'claude-sonnet-4-20250514': { released: '2025-05-14', priceIn: 3.00, priceOut: 15.00, company: 'Anthropic', type: 'LLM', sizeB: 100 },
            // OpenAI Current (https://openai.com/pricing)
            'GPT-4o': { released: '2024-05-13', priceIn: 2.50, priceOut: 10.00, company: 'OpenAI', type: 'LLM', sizeB: 200 },
            'GPT-4o Mini': { released: '2024-07-18', priceIn: 0.15, priceOut: 0.60, company: 'OpenAI', type: 'LLM', sizeB: 8 },
            'gpt-4o': { released: '2024-05-13', priceIn: 2.50, priceOut: 10.00, company: 'OpenAI', type: 'LLM', sizeB: 200 },
            'gpt-4o-mini': { released: '2024-07-18', priceIn: 0.15, priceOut: 0.60, company: 'OpenAI', type: 'LLM', sizeB: 8 },
            // OpenAI Legacy (GPT-4 ~1.8T MoE with 8 experts, effective ~220B)
            'GPT-4 Turbo': { released: '2024-04-09', priceIn: 10.00, priceOut: 30.00, company: 'OpenAI', type: 'LLM', sizeB: 220 },
            'GPT-4': { released: '2023-03-14', priceIn: 30.00, priceOut: 60.00, company: 'OpenAI', type: 'LLM', sizeB: 220 },
            'GPT-3.5 Turbo': { released: '2022-11-30', priceIn: 0.50, priceOut: 1.50, company: 'OpenAI', type: 'LLM', sizeB: 20 },
            'gpt-4-turbo': { released: '2024-04-09', priceIn: 10.00, priceOut: 30.00, company: 'OpenAI', type: 'LLM', sizeB: 220 },
            'gpt-4': { released: '2023-03-14', priceIn: 30.00, priceOut: 60.00, company: 'OpenAI', type: 'LLM', sizeB: 220 },
            'gpt-3.5-turbo': { released: '2022-11-30', priceIn: 0.50, priceOut: 1.50, company: 'OpenAI', type: 'LLM', sizeB: 20 },
            // DeepSeek V3 (671B MoE, 37B active)
            'DeepSeek Chat': { released: '2024-12-26', priceIn: 0.14, priceOut: 0.28, company: 'DeepSeek', type: 'LLM', sizeB: 671 },
            'deepseek-chat': { released: '2024-12-26', priceIn: 0.14, priceOut: 0.28, company: 'DeepSeek', type: 'LLM', sizeB: 671 },
            // Traditional MT APIs (price per 1M characters ‚âà tokens)
            // DeepL and Google charge per character, not per token
            // $20/1M chars ‚âà $5/1M tokens (assuming ~4 chars/token)
            'DeepL': { released: '2017-08-28', priceIn: 0, priceOut: 5.00, company: 'DeepL', type: 'NMT', sizeB: 2, perChar: true },
            'Google Translate': { released: '2016-11-15', priceIn: 0, priceOut: 5.00, company: 'Google', type: 'NMT', sizeB: 2, perChar: true },
            // Local models (free, run on your hardware)
            // Argos uses OpenNMT transformer models ~70-100M params
            'üñ•Ô∏è Argos Translate': { released: '2020-09-01', priceIn: 0, priceOut: 0, company: 'Open Source', type: 'Local', sizeB: 0.02, perPair: true },
            // NLLB-200: Meta's multilingual model in 3 sizes
            'üñ•Ô∏è NLLB-200 600M (Meta)': { released: '2022-07-06', priceIn: 0, priceOut: 0, company: 'Meta', type: 'Local', sizeB: 0.6 },
            'üñ•Ô∏è NLLB-200 1.3B (Meta)': { released: '2022-07-06', priceIn: 0, priceOut: 0, company: 'Meta', type: 'Local', sizeB: 1.3 },
            'üñ•Ô∏è NLLB-200 3.3B (Meta)': { released: '2022-07-06', priceIn: 0, priceOut: 0, company: 'Meta', type: 'Local', sizeB: 3.3 },
            // OPUS-MT: ~300MB per model ‚âà 74M params
            'üñ•Ô∏è OPUS-MT (Helsinki)': { released: '2020-05-01', priceIn: 0, priceOut: 0, company: 'Helsinki-NLP', type: 'Local', sizeB: 0.074, perPair: true },
            // Reference (human translation - no date/price applicable)
            'üìö Reference': { released: null, priceIn: 0, priceOut: 0, company: 'Human', type: 'Human', sizeB: null }
          };
          
          // Helper to get model metadata with fallback
          const getModelMeta = (modelName) => {
            // Try exact match first
            if (modelMetadata[modelName]) return modelMetadata[modelName];
            // Try partial match
            for (const [key, meta] of Object.entries(modelMetadata)) {
              if (modelName.toLowerCase().includes(key.toLowerCase()) || 
                  key.toLowerCase().includes(modelName.toLowerCase())) {
                return meta;
              }
            }
            // Default fallback
            return { released: '2024-01-01', priceIn: 1, priceOut: 1, company: 'Unknown', type: 'Unknown' };
          };

          const [selectedModels, setSelectedModels] = useState([
            availableModels.find(m => m.id === 'deepl'),
            availableModels.find(m => m.id === 'google'),
            availableModels.find(m => m.id === 'argos'),
            availableModels.find(m => m.id === 'nllb-200-600m'),
            availableModels.find(m => m.id === 'opus-mt')
          ].filter(Boolean));

          useEffect(() => {
            fetch('/api_keys.json')
              .then(r => r.json())
              .then(keys => {
                setApiKeys(keys);
                // Load evaluator key if available (prefer deepseek, then anthropic, then openai)
                if (keys.deepseek) {
                  setEvaluatorApiKey(keys.deepseek);
                } else if (keys.anthropic) {
                  setEvaluatorApiKey(keys.anthropic);
                } else if (keys.openai) {
                  setEvaluatorApiKey(keys.openai);
                }
                console.log('‚úÖ API keys loaded from file');
              })
              .catch(() => console.log('‚ö†Ô∏è No api_keys.json found, using manual entry'));
          }, []);

          // Clear/recalculate eval warning when switching modes
          useEffect(() => {
            if (evalData.length === 0) {
              setEvalWarning('');
              return;
            }
            
            // Recalculate warning based on current mode and loaded data
            const hasReference = evalData.some(row => {
              const ref = row['Reference Translation'] || row['Perfect Translation'] || 
                         row['Reference'] || row['Perfect'] || row['reference'];
              return ref && ref !== '';
            });
            
            if (mode === 'eval-ref' && !hasReference) {
              setEvalWarning('‚ö†Ô∏è No reference translations found! This file appears to be missing the "Reference Translation" column. Use "Eval without ref" mode instead, or load a file with reference translations.');
            } else if (mode === 'eval-noref' && hasReference) {
              setEvalWarning('üí° Info: This file contains reference translations. You can use "Evaluation with Reference" mode to get more accurate metrics (BLEU, CER, WER, etc.).');
            } else {
              setEvalWarning('');
            }
          }, [mode, evalData]);

          // Apply test selection helper (first N, random N, or range)
          const applyTestSelection = (fullData, selection, limit, startFrom) => {
            if (!fullData || fullData.length === 0) return [];
            
            let selected = [];
            const maxLimit = Math.min(limit, fullData.length);
            
            if (selection === 'random') {
              const shuffled = [...fullData].sort(() => Math.random() - 0.5);
              selected = shuffled.slice(0, maxLimit);
            } else if (selection === 'range') {
              const start = Math.min(startFrom, fullData.length - 1);
              selected = fullData.slice(start, start + maxLimit);
            } else {
              selected = fullData.slice(0, maxLimit);
            }
            
            return selected;
          };

          // Update test selection when parameters change
          useEffect(() => {
            if (testDataFull.length > 0) {
              const selected = applyTestSelection(testDataFull, testSelection, testLimit, testStartFrom);
              setTestData(selected);
              console.log(`üìä Re-selected ${selected.length} of ${testDataFull.length} tests`);
            }
          }, [testSelection, testLimit, testStartFrom, testDataFull]);

          // ==================== PRICING & TIMING ====================
          
          const modelPricing = {
            // Anthropic
            'claude-opus-4-5-20251101': { input: 5.00, output: 25.00 },
            'claude-sonnet-4-5-20250929': { input: 3.00, output: 15.00 },
            'claude-haiku-4-5-20251001': { input: 1.00, output: 5.00 },
            'claude-sonnet-4-20250514': { input: 3.00, output: 15.00 },
            'claude-opus-4-20250514': { input: 15.00, output: 75.00 },
            
            // OpenAI
            'gpt-4o': { input: 2.50, output: 10.00 },
            'gpt-4o-mini': { input: 0.15, output: 0.60 },
            
            // DeepSeek
            'deepseek-chat': { input: 0.14, output: 0.28 },
            
            // Cost services (price per 1M characters)
            'deepl': { input: 0, output: 0, fixedCostPerMChar: 20 },
            'google-translate': { input: 0, output: 0, fixedCostPerMChar: 20 },
            
            // Local models (FREE)
            'argos': { input: 0, output: 0, fixedCost: 0 },
            'nllb-200-600m': { input: 0, output: 0, fixedCost: 0 },
            'nllb-200-1.3b': { input: 0, output: 0, fixedCost: 0 },
            'nllb-200-3.3b': { input: 0, output: 0, fixedCost: 0 },
            'opus-mt': { input: 0, output: 0, fixedCost: 0 },
          };

          // Estimate tokens from text (rough estimate: ~4 chars per token for English, ~2-3 for others)
          const estimateTokens = (text) => {
            if (!text) return 0;
            // Average 3.5 characters per token across languages
            return Math.ceil(text.length / 3.5);
          };

          // Calculate cost in cents
          const calculateCost = (model, inputText, outputText, usage = null) => {
            const modelId = model.model || model.id;
            const pricing = modelPricing[modelId];
            
            if (!pricing) {
              // Unknown model, estimate based on provider
              if (model.provider === 'anthropic') {
                // Default to Sonnet pricing
                const inputTokens = usage?.input_tokens || estimateTokens(inputText);
                const outputTokens = usage?.output_tokens || estimateTokens(outputText);
                return ((inputTokens * 3.00 + outputTokens * 15.00) / 1000000) * 100;
              } else if (model.provider === 'openai') {
                // Default to GPT-4o pricing
                const inputTokens = usage?.prompt_tokens || estimateTokens(inputText);
                const outputTokens = usage?.completion_tokens || estimateTokens(outputText);
                return ((inputTokens * 2.50 + outputTokens * 10.00) / 1000000) * 100;
              }
              return 0;
            }
            
            if (pricing.fixedCostPerMChar) {
              const charCount = inputText?.length || 0;
              const costInDollars = (charCount / 1000000) * pricing.fixedCostPerMChar;
              return costInDollars * 100; // Convert to cents
            }
            
            // Token-based pricing
            const inputTokens = usage?.input_tokens || usage?.prompt_tokens || estimateTokens(inputText);
            const outputTokens = usage?.output_tokens || usage?.completion_tokens || estimateTokens(outputText);
            
            const costInDollars = (inputTokens * pricing.input + outputTokens * pricing.output) / 1000000;
            return costInDollars * 100; // Convert to cents
          };

          const handleAddModel = (e) => {
            const modelId = e.target.value;
            if (!modelId) return;
            
            const model = availableModels.find(m => m.id === modelId);
            if (model && !selectedModels.find(m => m.id === modelId)) {
              setSelectedModels([...selectedModels, model]);
            }
            e.target.value = '';
          };

          const handleRemoveModel = (modelId) => {
            setSelectedModels(selectedModels.filter(m => m.id !== modelId));
          };

          const buildTranslationPrompt = (fromLang, toLang, customPrompt = null) => {
            const fromName = languages.find(l => l.code === fromLang)?.name || fromLang;
            const toName = languages.find(l => l.code === toLang)?.name || toLang;
            
            if (customPrompt) {
              // If custom prompt already includes language info, use as-is but add strict output directive
              if (customPrompt.includes('Translate from') || customPrompt.includes('translate from')) {
                return `${customPrompt}\n\nIMPORTANT: Output ONLY the translated text. Do not add explanations, notes, commentary, or meta-discussion about the translation.`;
              }
              // Otherwise append language instruction and directive
              return `${customPrompt}\n\nTranslate from ${fromName} to ${toName}.\n\nIMPORTANT: Output ONLY the translated text. Do not add explanations, notes, commentary, or meta-discussion about the translation.`;
            }
            
            // Build default prompt
            let prompt = systemPrompt;
            if (styleInstructions) {
              prompt += `\n\n${styleInstructions}`;
            }
            prompt += `\n\nTranslate from ${fromName} to ${toName}.\n\nIMPORTANT: Output ONLY the translated text. Do not add explanations, notes, commentary, or meta-discussion about the translation.`;
            return prompt;
          };

          const translateWithModel = async (text, from, to, model, customPrompt = null) => {
            const startTime = Date.now();
            const fullPrompt = buildTranslationPrompt(from, to, customPrompt);
            
            try {
              if (model.provider === 'anthropic') {
                if (!apiKeys.anthropic) {
                  return { 
                    translation: 'Error: No Anthropic API key', 
                    fullPrompt, 
                    error: true,
                    time: 0,
                    cost: 0
                  };
                }
                
                const res = await fetch("/translate/anthropic", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                    text: text,
                    api_key: apiKeys.anthropic,
                    model: model.model,
                    system_prompt: fullPrompt,
                    temperature: 0.3,
                    max_tokens: 2000
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                const translation = data.translation;
                const cost = calculateCost(model, text, translation, data.usage);
                
                return { 
                  translation, 
                  fullPrompt, 
                  error: false,
                  time: timeMs,
                  cost: cost,
                  usage: data.usage
                };
              }

              if (model.provider === 'openai') {
                if (!apiKeys.openai) {
                  return { 
                    translation: 'Error: No OpenAI API key', 
                    fullPrompt, 
                    error: true,
                    time: 0,
                    cost: 0
                  };
                }
                
                const res = await fetch('/translate/openai', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    text: text,
                    api_key: apiKeys.openai,
                    model: model.model,
                    system_prompt: fullPrompt,
                    temperature: 0.3,
                    max_tokens: 2000
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                const translation = data.translation;
                const cost = calculateCost(model, text, translation, data.usage);
                
                return { 
                  translation, 
                  fullPrompt, 
                  error: false,
                  time: timeMs,
                  cost: cost,
                  usage: data.usage
                };
              }

              if (model.provider === 'deepseek') {
                if (!apiKeys.deepseek) {
                  return { 
                    translation: 'Error: No DeepSeek API key', 
                    fullPrompt, 
                    error: true,
                    time: 0,
                    cost: 0
                  };
                }
                
                const res = await fetch('/translate/deepseek', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    text,
                    source_lang: from,
                    target_lang: to,
                    api_key: apiKeys.deepseek,
                    model: model.model,
                    system_prompt: fullPrompt
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                const translation = data.translation;
                const cost = calculateCost(model, text, translation);
                
                return { 
                  translation, 
                  fullPrompt, 
                  error: false,
                  time: timeMs,
                  cost: cost
                };
              }

              if (model.provider === 'deepl') {
                if (!apiKeys.deepl) {
                  return { 
                    translation: 'Error: No DeepL API key', 
                    fullPrompt: 'DeepL (custom prompts not supported)', 
                    error: true,
                    time: 0,
                    cost: 0
                  };
                }
                
                const res = await fetch('/translate/deepl', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    text,
                    source_lang: from,
                    target_lang: to.toUpperCase(),
                    api_key: apiKeys.deepl
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                
                const data = await res.json();
                const translation = data.translation;
                const cost = calculateCost(model, text, translation);
                
                return { 
                  translation, 
                  fullPrompt: 'DeepL (custom prompts not supported)', 
                  error: false,
                  time: timeMs,
                  cost: cost
                };
              }

              if (model.provider === 'google') {
                if (!apiKeys.google) {
                  return { 
                    translation: 'Error: No Google API key', 
                    fullPrompt: 'Google Translate (custom prompts not supported)', 
                    error: true,
                    time: 0,
                    cost: 0
                  };
                }
                
                const res = await fetch(
                  `https://translation.googleapis.com/language/translate/v2?key=${apiKeys.google}`,
                  {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      q: text,
                      source: from,
                      target: to,
                      format: 'text'
                    })
                  }
                );
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                if (!res.ok) {
                  throw new Error(`HTTP ${res.status}`);
                }
                
                const data = await res.json();
                const translation = data.data.translations[0].translatedText;
                const cost = calculateCost(model, text, translation);
                
                return { 
                  translation, 
                  fullPrompt: 'Google Translate (custom prompts not supported)', 
                  error: false,
                  time: timeMs,
                  cost: cost
                };
              }

              // ==================== LOCAL MODELS ====================
              
              if (model.provider === 'argos') {
                const res = await fetch('/translate/argos', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text, source_lang: from, target_lang: to })
                });
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                const data = await res.json();
                return { translation: data.translation, fullPrompt: 'Argos Translate (local)', error: false, time: timeMs, cost: 0, local: true };
              }

              if (model.provider === 'nllb') {
                const res = await fetch('/translate/nllb', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text, source_lang: from, target_lang: to, model: model.model })
                });
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                const data = await res.json();
                return { translation: data.translation, fullPrompt: `NLLB-200 ${model.model} (local, 200 langs)`, error: false, time: timeMs, cost: 0, local: true };
              }

              if (model.provider === 'opus') {
                const res = await fetch('/translate/opus', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ text, source_lang: from, target_lang: to })
                });
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                if (!res.ok) {
                  const errorData = await res.json();
                  throw new Error(errorData.error || `HTTP ${res.status}`);
                }
                const data = await res.json();
                return { translation: data.translation, fullPrompt: 'OPUS-MT Helsinki (local)', error: false, time: timeMs, cost: 0, local: true };
              }

              return { 
                translation: 'Error: Unknown provider', 
                fullPrompt, 
                error: true,
                time: 0,
                cost: 0
              };
            } catch (error) {
              console.error(`Error with ${model.name}:`, error);
              return { 
                translation: `Error: ${error.message}`, 
                fullPrompt, 
                error: true,
                time: Date.now() - startTime,
                cost: 0
              };
            }
          };

          const handleTranslate = async () => {
            if (!sourceText.trim()) {
              alert('Please enter text to translate');
              return;
            }
            if (selectedModels.length === 0) {
              alert('Please add at least one translation model');
              return;
            }

            setIsTranslating(true);

            const results = {};
            // Use GUI system prompt directly
            const guiPrompt = buildTranslationPrompt(sourceLang, targetLang);
            
            for (const model of selectedModels) {
              const result = await translateWithModel(sourceText, sourceLang, targetLang, model);
              
              console.log(`‚úÖ ${model.name}: time=${result.time}ms, cost=$${(result.cost/100).toFixed(6)}`);
              
              results[model.id] = { 
                name: model.name, 
                translation: result.translation,
                error: result.error,
                time: result.time,
                cost: result.cost
              };
            }

            setTranslations([{
              id: Date.now(),
              timestamp: new Date().toLocaleString(),
              original: sourceText,
              sourceLang: languages.find(l => l.code === sourceLang)?.name,
              targetLang: languages.find(l => l.code === targetLang)?.name,
              systemPrompt: guiPrompt,
              results
            }, ...translations]);

            setIsTranslating(false);
          };

          // ============ STREAMING TMX PARSER FOR HUGE FILES (1GB+) ============
          // Reads file in small chunks, extracts pairs, stops when limit reached
          const parseStreamingTMX = async (file, srcLang, tgtLang, maxPairs = 10000) => {
            return new Promise((resolve, reject) => {
              const results = [];
              const srcLangLower = srcLang.toLowerCase();
              const tgtLangLower = tgtLang.toLowerCase();
              
              // Small chunks to avoid memory issues (1MB each)
              const chunkSize = 1 * 1024 * 1024;
              let offset = 0;
              let buffer = '';
              let pairsFound = 0;
              
              // Stop reading when we have enough pairs
              const readNextChunk = () => {
                // STOP CONDITIONS: enough pairs OR end of file
                if (pairsFound >= maxPairs) {
                  console.log(`‚úÖ Reached limit: ${pairsFound} pairs (stopped early, only read ${(offset / 1024 / 1024).toFixed(0)}MB)`);
                  resolve(results);
                  return;
                }
                
                if (offset >= file.size) {
                  console.log(`‚úÖ EOF: ${pairsFound} pairs from ${(file.size / 1024 / 1024).toFixed(0)}MB file`);
                  resolve(results);
                  return;
                }
                
                // Read next chunk
                const slice = file.slice(offset, Math.min(offset + chunkSize, file.size));
                const reader = new FileReader();
                
                reader.onload = (e) => {
                  buffer += e.target.result;
                  
                  // Extract complete <tu>...</tu> blocks using regex
                  const tuRegex = /<tu[^>]*>([\s\S]*?)<\/tu>/gi;
                  let match;
                  let lastIndex = 0;
                  
                  while ((match = tuRegex.exec(buffer)) !== null && pairsFound < maxPairs) {
                    lastIndex = tuRegex.lastIndex;
                    const tuContent = match[1];
                    
                    // Extract tuv pairs
                    const tuvRegex = /<tuv[^>]*(?:xml:lang|lang)=["']([^"']+)["'][^>]*>[\s\S]*?<seg>([\s\S]*?)<\/seg>/gi;
                    let original = null;
                    let translation = null;
                    const tuvs = [];
                    let tuvMatch;
                    
                    while ((tuvMatch = tuvRegex.exec(tuContent)) !== null) {
                      const lang = tuvMatch[1].toLowerCase().split('-')[0];
                      const text = tuvMatch[2].trim()
                        .replace(/&lt;/g, '<').replace(/&gt;/g, '>')
                        .replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&apos;/g, "'");
                      
                      tuvs.push({ lang, text });
                      if (lang === srcLangLower) original = text;
                      else if (lang === tgtLangLower) translation = text;
                    }
                    
                    // Fallback if language codes don't match
                    if (!original && tuvs.length >= 2) {
                      original = tuvs[0].text;
                      translation = tuvs[1].text;
                    }
                    
                    if (original && original.length > 0 && original.length < 5000) {
                      results.push({ original, translation: translation || null });
                      pairsFound++;
                    }
                  }
                  
                  // Keep only the unprocessed tail (last incomplete <tu>)
                  // Find last complete </tu> position
                  const lastTuEnd = buffer.lastIndexOf('</tu>');
                  if (lastTuEnd > -1) {
                    buffer = buffer.substring(lastTuEnd + 5);
                  } else if (buffer.length > 50000) {
                    // Safety: if buffer too large without any complete TU, reset
                    buffer = buffer.substring(buffer.length - 10000);
                  }
                  
                  offset += chunkSize;
                  
                  // Progress logging
                  if (pairsFound % 2000 === 0 && pairsFound > 0) {
                    console.log(`üìä ${pairsFound} pairs, ${(offset / 1024 / 1024).toFixed(0)}MB read...`);
                  }
                  
                  // Continue reading (setTimeout prevents UI freeze)
                  setTimeout(readNextChunk, 0);
                };
                
                reader.onerror = () => reject(new Error('Error reading file chunk'));
                reader.readAsText(slice);
              };
              
              console.log(`üìÇ Starting streaming parse (max ${maxPairs} pairs)...`);
              readNextChunk();
            });
          };

          // ============ OPUS PARALLEL FILES PARSER ============
          // Parses two plain text files (source and reference) where each line is a sentence
          // IMPORTANT: Lines must stay synchronized - don't filter empty lines during read!
          const parseOpusPair = async (sourceFile, refFile, maxPairs = 10000) => {
            console.log(`üìÇ Parsing OPUS pair: ${sourceFile.name} + ${refFile.name}`);
            
            const readLines = async (file) => {
              return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                  // Split by newlines but DON'T filter - keep line numbers synchronized
                  const lines = e.target.result.split('\n');
                  resolve(lines);
                };
                reader.onerror = () => reject(new Error(`Failed to read ${file.name}`));
                reader.readAsText(file);
              });
            };
            
            const [sourceLines, refLines] = await Promise.all([
              readLines(sourceFile),
              readLines(refFile)
            ]);
            
            console.log(`üìä Source: ${sourceLines.length} lines, Reference: ${refLines.length} lines`);
            
            if (sourceLines.length !== refLines.length) {
              console.warn(`‚ö†Ô∏è Line count mismatch! Source: ${sourceLines.length}, Ref: ${refLines.length}`);
            }
            
            const lineCount = Math.min(sourceLines.length, refLines.length);
            const pairs = [];
            
            // Keep pairs synchronized by index - only skip if BOTH are empty
            for (let i = 0; i < lineCount && pairs.length < maxPairs; i++) {
              const source = sourceLines[i].trim();
              const ref = refLines[i].trim();
              
              // Only add if both source and reference have content
              if (source && ref) {
                pairs.push({
                  original: source,
                  translation: ref
                });
              }
              // Log first few pairs for verification
              if (i < 3) {
                console.log(`  Line ${i}: "${source.substring(0,50)}..." ‚Üí "${ref.substring(0,50)}..."`);
              }
            }
            
            console.log(`‚úÖ Parsed ${pairs.length} valid pairs (from ${lineCount} lines)`);
            return pairs;
          };

          const handleFileUpload = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            setSelectedTestFile(file.name);
            
            const fileSizeMB = file.size / (1024 * 1024);
            const isTMX = file.name.endsWith('.tmx');
            
            try {
              let allTestCases = [];
              
              // TMX files ALWAYS use streaming parser (handles any size)
              if (isTMX) {
                console.log(`üìÇ TMX file (${fileSizeMB.toFixed(0)}MB) - streaming parser`);
                
                // For huge files, we only need to load what we'll actually use
                // testLimit * 2 gives some buffer for selection
                const maxPairs = Math.max(testLimit * 2, 1000);
                console.log(`üéØ Loading max ${maxPairs} pairs (testLimit=${testLimit})`);
                
                allTestCases = await parseStreamingTMX(file, testSourceLang, testTargetLang, maxPairs);
                
              } else {
                // JSON files - load normally (usually small)
                const content = await new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = (e) => resolve(e.target.result);
                  reader.onerror = () => reject(new Error('Failed to read file'));
                  reader.readAsText(file);
                });
                
                const json = JSON.parse(content);
                allTestCases = Array.isArray(json) ? json : (json.tests || []);
              }
              
              if (allTestCases.length === 0) {
                throw new Error(`No valid pairs found. Check language settings: ${testSourceLang} ‚Üí ${testTargetLang}`);
              }
              
              console.log(`‚úÖ Loaded ${allTestCases.length} test cases`);
              
              setTestDataFull(allTestCases);
              const selected = applyTestSelection(allTestCases, testSelection, testLimit, testStartFrom);
              setTestData(selected);
              console.log(`üìä Selected ${selected.length} of ${allTestCases.length} tests`);
              
            } catch (err) {
              console.error('‚ùå Error loading file:', err);
              alert('Error: ' + err.message);
              setTestDataFull([]);
              setTestData([]);
            }
          };

          // Handler for OPUS pair upload (two files)
          const handleOpusPairUpload = async (sourceFile, refFile) => {
            if (!sourceFile || !refFile) return;
            
            setSelectedTestFile(`${sourceFile.name} + ${refFile.name}`);
            
            try {
              const maxPairs = Math.max(testLimit * 2, 1000);
              console.log(`üéØ Loading max ${maxPairs} OPUS pairs`);
              
              const allTestCases = await parseOpusPair(sourceFile, refFile, maxPairs);
              
              if (allTestCases.length === 0) {
                throw new Error('No valid pairs found in files');
              }
              
              console.log(`‚úÖ Loaded ${allTestCases.length} OPUS test cases`);
              
              setTestDataFull(allTestCases);
              const selected = applyTestSelection(allTestCases, testSelection, testLimit, testStartFrom);
              setTestData(selected);
              console.log(`üìä Selected ${selected.length} of ${allTestCases.length} tests`);
              
            } catch (err) {
              console.error('‚ùå Error loading OPUS files:', err);
              alert('Error: ' + err.message);
              setTestDataFull([]);
              setTestData([]);
            }
          };


          const runTests = async () => {
            if (testData.length === 0) {
              alert('Please load a test file first (JSON or TMX)');
              return;
            }
            if (selectedModels.length === 0) {
              alert('Please add at least one model');
              return;
            }

            setIsLoadingTests(true);
            shouldStopRef.current = false;
            const results = [];

            // Use system prompt from GUI, not from file
            const guiSystemPrompt = systemPrompt;

            for (let i = 0; i < testData.length; i++) {
              // Check if stopped
              if (shouldStopRef.current) {
                console.log('‚èπÔ∏è Tests stopped by user');
                break;
              }
              
              const test = testData[i];
              
              console.log(`\nüß™ Test ${i + 1}/${testData.length}:`);
              console.log(`  Original: "${test.original.substring(0, 50)}..."`);
              console.log(`  Reference: "${test.translation ? test.translation.substring(0, 50) + '...' : 'NONE (reference-free)'}"`);
              
              // Build prompt using GUI system prompt (not from file)
              const fullTestPrompt = buildTranslationPrompt(
                testSourceLang, 
                testTargetLang, 
                guiSystemPrompt
              );
              
              const testResult = {
                original: test.original,
                reference: test.translation,
                systemPrompt: fullTestPrompt,
                sourceLang: languages.find(l => l.code === testSourceLang)?.name,
                targetLang: languages.find(l => l.code === testTargetLang)?.name,
                modelResults: {}
              };

              for (const model of selectedModels) {
                if (shouldStopRef.current) break;
                
                const result = await translateWithModel(
                  test.original,
                  testSourceLang,
                  testTargetLang,
                  model,
                  guiSystemPrompt
                );
                
                console.log(`  ü§ñ ${model.name}: time=${result.time}ms, cost=$${(result.cost/100).toFixed(6)}`);
                
                testResult.modelResults[model.id] = { 
                  name: model.name, 
                  translation: result.translation,
                  error: result.error,
                  time: result.time,
                  cost: result.cost
                };
              }

              results.push(testResult);
              setTestResults([...results]);
              
              console.log(`‚úÖ Completed test ${i + 1}/${testData.length}`);
            }

            setIsLoadingTests(false);
            shouldStopRef.current = false;
            console.log(`üéâ ${results.length}/${testData.length} tests completed`);
          };

          const exportToJSON = () => {
            if (translations.length === 0) {
              alert('No translations to export');
              return;
            }

            const data = translations.map(t => {
              const entry = {
                timestamp: t.timestamp,
                original: t.original,
                reference: '',
                sourceLang: t.sourceLang,
                targetLang: t.targetLang,
                systemPrompt: t.systemPrompt || '',
                translations: {}
              };
              
              Object.values(t.results).forEach(r => {
                entry.translations[r.name] = {
                  text: r.translation,
                  time: r.time !== undefined ? r.time / 1000 : undefined,
                  cost: r.cost !== undefined && r.cost > 0 ? r.cost / 100 : undefined
                };
              });
              return entry;
            });

            console.log('üì• Exporting to JSON:', data);
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `translations_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            console.log('‚úÖ JSON file exported successfully');
          };

          const exportTestResults = () => {
            if (testResults.length === 0) {
              alert('No test results to export');
              return;
            }

            const data = testResults.map(t => {
              const entry = {
                original: t.original,
                reference: t.reference || null,
                sourceLang: t.sourceLang || '',
                targetLang: t.targetLang || '',
                systemPrompt: t.systemPrompt || '',
                translations: {}
              };
              
              Object.values(t.modelResults).forEach(r => {
                entry.translations[r.name] = {
                  text: r.translation,
                  time: r.time !== undefined ? r.time / 1000 : undefined,
                  cost: r.cost !== undefined && r.cost > 0 ? r.cost / 100 : undefined
                };
              });
              return entry;
            });

            console.log('üì• Exporting test results to JSON:', data);
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `test_results_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            console.log('‚úÖ Test results exported to JSON');
          };

          // ==================== EVALUATION FUNCTIONS ====================
          
          const handleEvalFileUpload = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            setSelectedEvalFile(file.name);
            setEvalWarning('');
            
            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const content = event.target.result;
                let jsonData = [];
                
                // Parse JSON file
                const parsed = JSON.parse(content);
                
                // Check if this is an exported evaluation results file
                if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].evaluations) {
                  // This is an exported results file - load directly into evalResults
                  console.log('üìä Detected exported evaluation results file');
                  
                  // Convert back to evalResults format
                  const loadedResults = parsed.map(row => ({
                    original: row.original,
                    reference: row.reference,
                    fromLang: row.sourceLang,
                    toLang: row.targetLang,
                    evaluations: Object.fromEntries(
                      Object.entries(row.evaluations).map(([model, metrics]) => [
                        model,
                        {
                          translation: metrics.translation,
                          time: metrics.time !== undefined ? metrics.time * 1000 : undefined, // Convert back to ms
                          cost: metrics.cost !== undefined ? metrics.cost * 100 : undefined, // Convert back to cents
                          bleu: metrics.bleu,
                          meteor: metrics.meteor,
                          total: metrics.total,
                          cer: metrics.cer,
                          wer: metrics.wer,
                          jaccard: metrics.jaccard,
                          chrF: metrics.chrF,
                          lengthRatio: metrics.lengthRatio,
                          bertScore: metrics.bertScore,
                          comet: metrics.comet,
                          bleurt: metrics.bleurt,
                          cometQE: metrics.cometQE,
                          repetition: metrics.repetition,
                          numberPres: metrics.numberPres,
                          copyRate: metrics.copyRate,
                          score: metrics.llmScore,
                          fluency: metrics.fluency,
                          adequacy: metrics.adequacy,
                          charCount: metrics.charCount,
                          wordCount: metrics.wordCount,
                          feedback: metrics.feedback,
                          _isReference: model.includes('Reference')
                        }
                      ])
                    )
                  }));
                  
                  setEvalResults(loadedResults);
                  setEvalData([]); // Clear eval data since we have results
                  setEvalWarning('‚úÖ Loaded previous evaluation results. You can view them below.');
                  console.log(`‚úÖ Loaded ${loadedResults.length} evaluation results`);
                  return;
                }
                
                // Support multiple formats:
                // 1. Array of {original, reference, translations: {model: {text}}}
                // 2. Array of flat objects with columns
                if (Array.isArray(parsed)) {
                  jsonData = parsed.map(row => {
                    // Convert new format to flat format for compatibility
                    if (row.translations && typeof row.translations === 'object') {
                      const flat = {
                        'Original': row.original,
                        'Reference Translation': row.reference || '',
                        'From': row.sourceLang || '',
                        'To': row.targetLang || ''
                      };
                      
                      // Add each model translation as a column
                      Object.entries(row.translations).forEach(([model, data]) => {
                        flat[model] = typeof data === 'object' ? data.text : data;
                        if (data.time) flat[`${model} - Time (s)`] = data.time;
                        if (data.cost) flat[`${model} - Cost ($)`] = data.cost;
                      });
                      
                      return flat;
                    }
                    return row;
                  });
                } else {
                  throw new Error('Invalid JSON format');
                }
                
                // Check if file has reference translations
                const hasReference = jsonData.some(row => {
                  const ref = row['Reference Translation'] || row['Perfect Translation'] || 
                             row['Reference'] || row['Perfect'] || row['reference'];
                  return ref && ref !== '';
                });
                
                // Warn if mode doesn't match file content
                if (mode === 'eval-ref' && !hasReference) {
                  setEvalWarning('‚ö†Ô∏è No reference translations found! Use "Eval without ref" mode instead.');
                } else if (mode === 'eval-noref' && hasReference) {
                  setEvalWarning('üí° Info: This file contains reference translations. You can use "Evaluation with Reference" mode for more accurate metrics.');
                }
                
                setEvalData(jsonData);
                setEvalResults([]); // Clear previous results
                console.log(`‚úÖ Loaded ${jsonData.length} translations for evaluation`);
              } catch (err) {
                alert('Error loading JSON: ' + err.message);
                console.error(err);
              }
            };
            reader.readAsText(file);
          };

          // ==================== UNIVERSAL TOKENIZER ====================
          // Handles CJK (Chinese, Japanese, Korean) and alphabetic languages
          const isCJK = (text) => {
            // Check if text contains CJK characters
            const cjkRegex = /[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF]/;
            return cjkRegex.test(text);
          };
          
          const tokenize = (text) => {
            const lower = text.toLowerCase();
            if (isCJK(text)) {
              // For CJK: character-based tokenization
              // Filter out punctuation and whitespace, keep CJK chars and letters
              return [...lower].filter(c => 
                /[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\w]/.test(c) && 
                !/\s/.test(c)
              );
            } else {
              // For alphabetic languages: word-based tokenization
              return lower.match(/\b\w+\b/g) || [];
            }
          };

          // Improved BLEU Score (using 1-gram to 4-gram precision)
          const calculateBLEU = (reference, candidate) => {
            const refTokens = tokenize(reference);
            const candTokens = tokenize(candidate);
            
            if (candTokens.length === 0) return "0.00";
            
            // For CJK with short texts, use fewer n-grams
            const maxN = Math.min(4, Math.min(refTokens.length, candTokens.length));
            if (maxN === 0) return "0.00";
            
            // Calculate n-gram precisions (1 to maxN)
            const ngramPrecisions = [];
            for (let n = 1; n <= maxN; n++) {
              const refNgrams = {};
              const candNgrams = {};
              
              for (let i = 0; i <= refTokens.length - n; i++) {
                const ngram = refTokens.slice(i, i + n).join('');
                refNgrams[ngram] = (refNgrams[ngram] || 0) + 1;
              }
              
              for (let i = 0; i <= candTokens.length - n; i++) {
                const ngram = candTokens.slice(i, i + n).join('');
                candNgrams[ngram] = (candNgrams[ngram] || 0) + 1;
              }
              
              let matches = 0;
              let total = 0;
              for (const ngram in candNgrams) {
                total += candNgrams[ngram];
                if (refNgrams[ngram]) {
                  matches += Math.min(candNgrams[ngram], refNgrams[ngram]);
                }
              }
              
              ngramPrecisions.push(total > 0 ? matches / total : 0);
            }
            
            // Geometric mean of precisions
            const logSum = ngramPrecisions.reduce((sum, p) => sum + Math.log(p + 1e-10), 0);
            const geometricMean = Math.exp(logSum / ngramPrecisions.length);
            
            // Brevity penalty
            const brevityPenalty = candTokens.length >= refTokens.length ? 1 : 
                                   Math.exp(1 - refTokens.length / candTokens.length);
            
            return (geometricMean * brevityPenalty * 100).toFixed(2);
          };

          // Levenshtein distance for CER/WER
          const levenshteinDistance = (a, b) => {
            const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(0));

            for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= b.length; j++) matrix[j][0] = j;

            for (let j = 1; j <= b.length; j++) {
              for (let i = 1; i <= a.length; i++) {
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                matrix[j][i] = Math.min(
                  matrix[j - 1][i] + 1,
                  matrix[j][i - 1] + 1,
                  matrix[j - 1][i - 1] + cost
                );
              }
            }

            return matrix[b.length][a.length];
          };

          // Character Error Rate
          const calculateCER = (reference, candidate) => {
            const distance = levenshteinDistance(reference, candidate);
            return ((distance / reference.length) * 100).toFixed(2);
          };

          // Word Error Rate (or Character Error Rate for CJK)
          const calculateWER = (reference, candidate) => {
            const refTokens = tokenize(reference);
            const candTokens = tokenize(candidate);
            
            if (refTokens.length === 0) return "0.00";
            
            const distance = levenshteinDistance(refTokens, candTokens);
            return ((distance / refTokens.length) * 100).toFixed(2);
          };

          // ==================== METEOR with Synonyms ====================
          // Use external synonyms dictionary if loaded, otherwise use built-in
          const synonymGroups = window.synonymGroups || {
            en: [
              ['go', 'walk', 'move', 'travel', 'proceed', 'advance', 'progress'],
              ['run', 'sprint', 'dash', 'race', 'rush', 'hurry', 'bolt'],
              ['say', 'tell', 'speak', 'talk', 'state', 'declare', 'mention', 'express'],
              ['ask', 'question', 'inquire', 'query', 'request', 'demand'],
              ['think', 'believe', 'consider', 'suppose', 'assume', 'reckon', 'deem'],
              ['know', 'understand', 'realize', 'recognize', 'comprehend', 'grasp'],
              ['see', 'look', 'watch', 'view', 'observe', 'notice', 'spot', 'witness'],
              ['make', 'create', 'build', 'construct', 'produce', 'manufacture', 'form'],
              ['get', 'obtain', 'acquire', 'receive', 'gain', 'achieve', 'attain'],
              ['give', 'provide', 'offer', 'present', 'donate', 'grant', 'supply'],
              ['take', 'grab', 'seize', 'capture', 'remove', 'accept', 'receive'],
              ['find', 'discover', 'locate', 'detect', 'uncover', 'spot'],
              ['use', 'utilize', 'employ', 'apply', 'operate', 'handle'],
              ['help', 'assist', 'aid', 'support', 'serve', 'facilitate'],
              ['want', 'wish', 'desire', 'need', 'require', 'crave'],
              ['like', 'enjoy', 'love', 'prefer', 'fancy', 'appreciate'],
              ['big', 'large', 'huge', 'enormous', 'vast', 'massive', 'giant'],
              ['small', 'little', 'tiny', 'minute', 'mini', 'compact'],
              ['good', 'great', 'excellent', 'fine', 'wonderful', 'superb'],
              ['bad', 'poor', 'terrible', 'awful', 'horrible', 'dreadful'],
              ['new', 'fresh', 'modern', 'recent', 'novel', 'latest'],
              ['old', 'ancient', 'aged', 'elderly', 'vintage', 'antique'],
              ['fast', 'quick', 'rapid', 'swift', 'speedy', 'hasty'],
              ['slow', 'gradual', 'leisurely', 'sluggish', 'unhurried'],
              ['happy', 'glad', 'joyful', 'pleased', 'delighted', 'cheerful'],
              ['sad', 'unhappy', 'sorrowful', 'depressed', 'miserable'],
              ['angry', 'mad', 'furious', 'annoyed', 'irritated', 'enraged'],
              ['afraid', 'scared', 'frightened', 'terrified', 'fearful'],
              ['important', 'significant', 'crucial', 'vital', 'essential', 'key'],
              ['difficult', 'hard', 'challenging', 'tough', 'complex'],
              ['easy', 'simple', 'straightforward', 'effortless', 'basic'],
              ['beautiful', 'pretty', 'lovely', 'gorgeous', 'attractive', 'stunning'],
              ['smart', 'intelligent', 'clever', 'bright', 'brilliant', 'wise'],
              ['stupid', 'dumb', 'foolish', 'silly', 'idiotic', 'dense'],
              ['true', 'correct', 'right', 'accurate', 'valid', 'genuine'],
              ['false', 'wrong', 'incorrect', 'inaccurate', 'fake', 'untrue'],
              ['start', 'begin', 'commence', 'initiate', 'launch', 'kick off'],
              ['end', 'finish', 'complete', 'conclude', 'terminate', 'stop'],
              ['change', 'alter', 'modify', 'transform', 'adjust', 'vary'],
              ['work', 'function', 'operate', 'perform', 'labor', 'toil']
            ],
            de: [
              ['gehen', 'laufen', 'wandern', 'schreiten', 'spazieren'],
              ['sagen', 'sprechen', 'reden', 'erz√§hlen', 'mitteilen', '√§u√üern'],
              ['fragen', 'anfragen', 'erkundigen', 'befragen', 'bitten'],
              ['denken', 'glauben', 'meinen', 'vermuten', 'annehmen'],
              ['wissen', 'verstehen', 'kennen', 'begreifen', 'erkennen'],
              ['sehen', 'schauen', 'blicken', 'betrachten', 'beobachten'],
              ['machen', 'tun', 'erstellen', 'herstellen', 'produzieren'],
              ['bekommen', 'erhalten', 'kriegen', 'empfangen', 'erlangen'],
              ['geben', 'schenken', '√ºberreichen', '√ºbergeben', 'spenden'],
              ['nehmen', 'greifen', 'ergreifen', 'fassen', 'packen'],
              ['finden', 'entdecken', 'aufsp√ºren', 'lokalisieren'],
              ['benutzen', 'verwenden', 'gebrauchen', 'nutzen', 'anwenden'],
              ['helfen', 'unterst√ºtzen', 'assistieren', 'beistehen'],
              ['wollen', 'm√∂chten', 'w√ºnschen', 'begehren', 'verlangen'],
              ['m√∂gen', 'lieben', 'gernhaben', 'sch√§tzen', 'bevorzugen'],
              ['gro√ü', 'riesig', 'enorm', 'gewaltig', 'massiv', 'm√§chtig'],
              ['klein', 'winzig', 'mini', 'gering', 'kompakt', 'zierlich'],
              ['gut', 'prima', 'toll', 'super', 'ausgezeichnet', 'hervorragend'],
              ['schlecht', 'schlimm', '√ºbel', 'mies', 'furchtbar', 'schrecklich'],
              ['neu', 'frisch', 'modern', 'aktuell', 'neuartig'],
              ['alt', 'antik', 'betagt', 'veraltet', 'uralt'],
              ['schnell', 'rasch', 'fix', 'z√ºgig', 'flott', 'eilig'],
              ['langsam', 'gem√§chlich', 'tr√§ge', 'schleppend'],
              ['gl√ºcklich', 'froh', 'fr√∂hlich', 'zufrieden', 'erfreut'],
              ['traurig', 'betr√ºbt', 'niedergeschlagen', 'deprimiert'],
              ['wichtig', 'bedeutend', 'wesentlich', 'entscheidend', 'essentiell'],
              ['schwierig', 'schwer', 'kompliziert', 'anspruchsvoll'],
              ['einfach', 'leicht', 'simpel', 'unkompliziert', 'm√ºhelos'],
              ['sch√∂n', 'h√ºbsch', 'attraktiv', 'reizend', 'anmutig'],
              ['klug', 'intelligent', 'schlau', 'clever', 'gescheit', 'weise'],
              ['wahr', 'richtig', 'korrekt', 'zutreffend', 'echt'],
              ['falsch', 'fehlerhaft', 'inkorrekt', 'unrichtig', 'unwahr'],
              ['anfangen', 'beginnen', 'starten', 'loslegen', 'einleiten'],
              ['beenden', 'abschlie√üen', 'vollenden', 'fertigstellen']
            ],
            ru: [
              ['–∏–¥—Ç–∏', '—Ö–æ–¥–∏—Ç—å', '—à–∞–≥–∞—Ç—å', '–¥–≤–∏–≥–∞—Ç—å—Å—è', '–ø–µ—Ä–µ–º–µ—â–∞—Ç—å—Å—è'],
              ['–±–µ–∂–∞—Ç—å', '–º—á–∞—Ç—å—Å—è', '–Ω–µ—Å—Ç–∏—Å—å', '—Å–ø–µ—à–∏—Ç—å', '—Ç–æ—Ä–æ–ø–∏—Ç—å—Å—è'],
              ['–≥–æ–≤–æ—Ä–∏—Ç—å', '—Å–∫–∞–∑–∞—Ç—å', '—Ä–∞—Å—Å–∫–∞–∑–∞—Ç—å', '–º–æ–ª–≤–∏—Ç—å', '–ø—Ä–æ–∏–∑–Ω–µ—Å—Ç–∏'],
              ['—Å–ø—Ä–∞—à–∏–≤–∞—Ç—å', '—Å–ø—Ä–æ—Å–∏—Ç—å', '–∑–∞–¥–∞–≤–∞—Ç—å', '–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞—Ç—å—Å—è'],
              ['–¥—É–º–∞—Ç—å', '–ø–æ–ª–∞–≥–∞—Ç—å', '—Å—á–∏—Ç–∞—Ç—å', '—Ä–∞–∑–º—ã—à–ª—è—Ç—å', '–º—ã—Å–ª–∏—Ç—å'],
              ['–∑–Ω–∞—Ç—å', '–ø–æ–Ω–∏–º–∞—Ç—å', '–æ—Å–æ–∑–Ω–∞–≤–∞—Ç—å', '–≤–µ–¥–∞—Ç—å', '—Ä–∞–∑—É–º–µ—Ç—å'],
              ['–≤–∏–¥–µ—Ç—å', '—Å–º–æ—Ç—Ä–µ—Ç—å', '–≥–ª—è–¥–µ—Ç—å', '–Ω–∞–±–ª—é–¥–∞—Ç—å', '–∑–∞–º–µ—á–∞—Ç—å'],
              ['–¥–µ–ª–∞—Ç—å', '—Å–æ–∑–¥–∞–≤–∞—Ç—å', '–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—å', '–∏–∑–≥–æ—Ç–∞–≤–ª–∏–≤–∞—Ç—å'],
              ['–ø–æ–ª—É—á–∞—Ç—å', '–ø—Ä–∏–æ–±—Ä–µ—Ç–∞—Ç—å', '–æ–±—Ä–µ—Ç–∞—Ç—å', '–¥–æ–±—ã–≤–∞—Ç—å'],
              ['–¥–∞–≤–∞—Ç—å', '–¥–∞—Ä–∏—Ç—å', '–≤—Ä—É—á–∞—Ç—å', '–ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—Ç—å'],
              ['–±—Ä–∞—Ç—å', '–≤–∑—è—Ç—å', '—Ö–≤–∞—Ç–∞—Ç—å', '–∑–∞–±–∏—Ä–∞—Ç—å', '–ø—Ä–∏–Ω–∏–º–∞—Ç—å'],
              ['–Ω–∞—Ö–æ–¥–∏—Ç—å', '–æ–±–Ω–∞—Ä—É–∂–∏–≤–∞—Ç—å', '–æ—Ç—ã—Å–∫–∏–≤–∞—Ç—å', '–æ—Ç–∫—Ä—ã–≤–∞—Ç—å'],
              ['–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å', '–ø—Ä–∏–º–µ–Ω—è—Ç—å', '—É–ø–æ—Ç—Ä–µ–±–ª—è—Ç—å', '–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è'],
              ['–ø–æ–º–æ–≥–∞—Ç—å', '—Å–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å', '–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å', '—Å–ø–æ—Å–æ–±—Å—Ç–≤–æ–≤–∞—Ç—å'],
              ['—Ö–æ—Ç–µ—Ç—å', '–∂–µ–ª–∞—Ç—å', '—Å—Ç—Ä–µ–º–∏—Ç—å—Å—è', '–∂–∞–∂–¥–∞—Ç—å'],
              ['–ª—é–±–∏—Ç—å', '–æ–±–æ–∂–∞—Ç—å', '–Ω—Ä–∞–≤–∏—Ç—å—Å—è', '–ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞—Ç—å'],
              ['–±–æ–ª—å—à–æ–π', '–∫—Ä—É–ø–Ω—ã–π', '–æ–≥—Ä–æ–º–Ω—ã–π', '–≥—Ä–æ–º–∞–¥–Ω—ã–π', '–≤–µ–ª–∏–∫–∏–π'],
              ['–º–∞–ª–µ–Ω—å–∫–∏–π', '–Ω–µ–±–æ–ª—å—à–æ–π', '–º–µ–ª–∫–∏–π', '–∫—Ä–æ—à–µ—á–Ω—ã–π', '–º–∏–Ω–∏–∞—Ç—é—Ä–Ω—ã–π'],
              ['—Ö–æ—Ä–æ—à–∏–π', '–æ—Ç–ª–∏—á–Ω—ã–π', '–ø—Ä–µ–∫—Ä–∞—Å–Ω—ã–π', '–∑–∞–º–µ—á–∞—Ç–µ–ª—å–Ω—ã–π'],
              ['–ø–ª–æ—Ö–æ–π', '—Å–∫–≤–µ—Ä–Ω—ã–π', '–¥—É—Ä–Ω–æ–π', '—É–∂–∞—Å–Ω—ã–π', '–æ—Ç–≤—Ä–∞—Ç–∏—Ç–µ–ª—å–Ω—ã–π'],
              ['–Ω–æ–≤—ã–π', '—Å–≤–µ–∂–∏–π', '—Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π', '–Ω–æ–≤–µ–π—à–∏–π'],
              ['—Å—Ç–∞—Ä—ã–π', '–¥—Ä–µ–≤–Ω–∏–π', '—Å—Ç–∞—Ä–∏–Ω–Ω—ã–π', '–≤–µ—Ç—Ö–∏–π', '—É—Å—Ç–∞—Ä–µ–≤—à–∏–π'],
              ['–±—ã—Å—Ç—Ä—ã–π', '—Å–∫–æ—Ä—ã–π', '—Å—Ç—Ä–µ–º–∏—Ç–µ–ª—å–Ω—ã–π', '–º–æ–ª–Ω–∏–µ–Ω–æ—Å–Ω—ã–π'],
              ['–º–µ–¥–ª–µ–Ω–Ω—ã–π', '–Ω–µ—Ç–æ—Ä–æ–ø–ª–∏–≤—ã–π', '–Ω–µ—Å–ø–µ—à–Ω—ã–π', '–≤—è–ª—ã–π'],
              ['—Å—á–∞—Å—Ç–ª–∏–≤—ã–π', '—Ä–∞–¥–æ—Å—Ç–Ω—ã–π', '–¥–æ–≤–æ–ª—å–Ω—ã–π', '–≤–µ—Å—ë–ª—ã–π'],
              ['–≥—Ä—É—Å—Ç–Ω—ã–π', '–ø–µ—á–∞–ª—å–Ω—ã–π', '—É–Ω—ã–ª—ã–π', '—Ç–æ—Å–∫–ª–∏–≤—ã–π'],
              ['–≤–∞–∂–Ω—ã–π', '–∑–Ω–∞—á–∏–º—ã–π', '—Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π', '–∫–ª—é—á–µ–≤–æ–π'],
              ['—Ç—Ä—É–¥–Ω—ã–π', '—Å–ª–æ–∂–Ω—ã–π', '—Ç—è–∂—ë–ª—ã–π', '–Ω–µ–ø—Ä–æ—Å—Ç–æ–π'],
              ['–ª—ë–≥–∫–∏–π', '–ø—Ä–æ—Å—Ç–æ–π', '–Ω–µ—Å–ª–æ–∂–Ω—ã–π', '—ç–ª–µ–º–µ–Ω—Ç–∞—Ä–Ω—ã–π'],
              ['–∫—Ä–∞—Å–∏–≤—ã–π', '–ø—Ä–µ–∫—Ä–∞—Å–Ω—ã–π', '–ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–π', '—Å–∏–º–ø–∞—Ç–∏—á–Ω—ã–π'],
              ['—É–º–Ω—ã–π', '—Å–º—ã—à–ª—ë–Ω—ã–π', '—Å–æ–æ–±—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã–π', '–º—É–¥—Ä—ã–π'],
              ['–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π', '–≤–µ—Ä–Ω—ã–π', '–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π', '—Ç–æ—á–Ω—ã–π'],
              ['–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π', '–æ—à–∏–±–æ—á–Ω—ã–π', '–Ω–µ–≤–µ—Ä–Ω—ã–π', '–ª–æ–∂–Ω—ã–π'],
              ['–Ω–∞—á–∏–Ω–∞—Ç—å', '–Ω–∞—á–∞—Ç—å', '–ø—Ä–∏—Å—Ç—É–ø–∞—Ç—å', '—Å—Ç–∞—Ä—Ç–æ–≤–∞—Ç—å'],
              ['–∑–∞–∫–∞–Ω—á–∏–≤–∞—Ç—å', '–∑–∞–≤–µ—Ä—à–∞—Ç—å', '–æ–∫–∞–Ω—á–∏–≤–∞—Ç—å', '–ø—Ä–µ–∫—Ä–∞—â–∞—Ç—å']
            ]
          };

          // Build synonym lookup map for fast access
          const buildSynonymMap = (lang) => {
            const map = new Map();
            const groups = synonymGroups[lang] || synonymGroups['en'];
            groups.forEach((group, idx) => {
              group.forEach(word => {
                const lower = word.toLowerCase();
                if (!map.has(lower)) map.set(lower, new Set());
                group.forEach(syn => map.get(lower).add(syn.toLowerCase()));
              });
            });
            return map;
          };

          // Check if two words are synonyms
          const areSynonyms = (word1, word2, synonymMap) => {
            const w1 = word1.toLowerCase();
            const w2 = word2.toLowerCase();
            if (w1 === w2) return true;
            const syns = synonymMap.get(w1);
            return syns ? syns.has(w2) : false;
          };

          // METEOR Score calculation with synonyms
          // For CJK languages without synonym dictionary, uses only exact matches
          const calculateMETEOR = (reference, candidate, lang = 'en') => {
            const refTokens = tokenize(reference);
            const candTokens = tokenize(candidate);
            
            if (refTokens.length === 0 || candTokens.length === 0) return "0.00";
            
            // Only use synonyms for languages that have them
            const hasSynonyms = synonymGroups[lang] && synonymGroups[lang].length > 0;
            const synonymMap = hasSynonyms ? buildSynonymMap(lang) : new Map();
            
            // Find matches (exact + synonyms for supported languages)
            const refMatched = new Set();
            const candMatched = new Set();
            
            // First pass: exact matches
            candTokens.forEach((cToken, cIdx) => {
              refTokens.forEach((rToken, rIdx) => {
                if (!refMatched.has(rIdx) && !candMatched.has(cIdx)) {
                  if (cToken === rToken) {
                    refMatched.add(rIdx);
                    candMatched.add(cIdx);
                  }
                }
              });
            });
            
            // Second pass: synonym matches (only if we have synonyms)
            if (hasSynonyms) {
              candTokens.forEach((cToken, cIdx) => {
                if (candMatched.has(cIdx)) return;
                refTokens.forEach((rToken, rIdx) => {
                  if (!refMatched.has(rIdx) && !candMatched.has(cIdx)) {
                    if (areSynonyms(cToken, rToken, synonymMap)) {
                      refMatched.add(rIdx);
                      candMatched.add(cIdx);
                    }
                  }
                });
              });
            }
            
            const matches = candMatched.size;
            if (matches === 0) return "0.00";
            
            // Precision and Recall
            const precision = matches / candTokens.length;
            const recall = matches / refTokens.length;
            
            // F-mean with alpha=0.9 (recall weighted higher)
            const alpha = 0.9;
            const fMean = (precision * recall) / (alpha * precision + (1 - alpha) * recall);
            
            // Fragmentation penalty (chunks)
            let chunks = 0;
            let inChunk = false;
            for (let i = 0; i < candTokens.length; i++) {
              if (candMatched.has(i)) {
                if (!inChunk) {
                  chunks++;
                  inChunk = true;
                }
              } else {
                inChunk = false;
              }
            }
            
            const fragPenalty = 0.5 * Math.pow(chunks / matches, 3);
            const meteor = fMean * (1 - fragPenalty);
            
            return (meteor * 100).toFixed(2);
          };

          // Calculate Total Score with weights (eval-ref mode)
          // All metrics normalized to 0-100 scale where higher = better
          const calculateTotalScore = (metrics) => {
            let totalWeight = 0;
            let weightedSum = 0;
            
            // BLEU: 0-100, higher is better - use as is
            if (metrics.bleu !== undefined && metricWeights.bleu > 0) {
              const val = parseFloat(metrics.bleu) || 0;
              weightedSum += val * metricWeights.bleu;
              totalWeight += metricWeights.bleu;
            }
            
            // METEOR: 0-100, higher is better - use as is
            if (metrics.meteor !== undefined && metricWeights.meteor > 0) {
              const val = parseFloat(metrics.meteor) || 0;
              weightedSum += val * metricWeights.meteor;
              totalWeight += metricWeights.meteor;
            }
            
            // CER: 0-100%, lower is better - invert: 100 - CER
            if (metrics.cer !== undefined && metricWeights.cer > 0) {
              const val = Math.max(0, 100 - (parseFloat(metrics.cer) || 0));
              weightedSum += val * metricWeights.cer;
              totalWeight += metricWeights.cer;
            }
            
            // WER: 0-100%, lower is better - invert: 100 - WER
            if (metrics.wer !== undefined && metricWeights.wer > 0) {
              const val = Math.max(0, 100 - (parseFloat(metrics.wer) || 0));
              weightedSum += val * metricWeights.wer;
              totalWeight += metricWeights.wer;
            }
            
            // Jaccard: 0-100%, higher is better - use as is
            if (metrics.jaccard !== undefined && metricWeights.jaccard > 0) {
              const val = parseFloat(metrics.jaccard) || 0;
              weightedSum += val * metricWeights.jaccard;
              totalWeight += metricWeights.jaccard;
            }
            
            // chrF: 0-100, higher is better - use as is
            if (metrics.chrF !== undefined && metricWeights.chrf > 0) {
              const val = parseFloat(metrics.chrF) || 0;
              weightedSum += val * metricWeights.chrf;
              totalWeight += metricWeights.chrf;
            }
            
            // Length Ratio: optimal at 100% - penalize deviation
            if (metrics.lengthRatio !== undefined && metricWeights.lengthRatio > 0) {
              const ratio = parseFloat(metrics.lengthRatio) || 100;
              const deviation = Math.abs(ratio - 100);
              // 100% ‚Üí 100, 90%/110% ‚Üí 80, 80%/120% ‚Üí 60, etc.
              const score = Math.max(0, 100 - deviation * 2);
              weightedSum += score * metricWeights.lengthRatio;
              totalWeight += metricWeights.lengthRatio;
            }
            
            // BERTScore: already 0-100 (multiplied by 100 when received), higher is better
            if (metrics.bertScore !== undefined && metrics.bertScore !== 'N/A' && metricWeights.bertScore > 0) {
              const val = parseFloat(metrics.bertScore) || 0;
              weightedSum += val * metricWeights.bertScore;
              totalWeight += metricWeights.bertScore;
            }
            
            // COMET: 0-1 scale, higher is better - multiply by 100
            if (metrics.comet !== undefined && metrics.comet !== 'N/A' && metricWeights.comet > 0) {
              const val = (parseFloat(metrics.comet) || 0) * 100;
              weightedSum += val * metricWeights.comet;
              totalWeight += metricWeights.comet;
            }
            
            // BLEURT: typically -2 to +1 scale, higher is better - normalize to 0-100
            // Map: -2 ‚Üí 0, 0 ‚Üí 66, 1 ‚Üí 100
            if (metrics.bleurt !== undefined && metrics.bleurt !== 'N/A' && metricWeights.bleurt > 0) {
              const rawVal = parseFloat(metrics.bleurt) || 0;
              // Normalize from [-2, 1] to [0, 100]
              const val = Math.max(0, Math.min(100, ((rawVal + 2) / 3) * 100));
              weightedSum += val * metricWeights.bleurt;
              totalWeight += metricWeights.bleurt;
            }
            
            if (totalWeight === 0) return "N/A";
            return (weightedSum / totalWeight).toFixed(1);
          };

          // Calculate No-Reference Total Score with weights (eval-noref mode)
          // All metrics normalized to 0-100 scale where higher = better
          const calculateNoRefTotalScore = (metrics) => {
            let totalWeight = 0;
            let weightedSum = 0;
            
            // Repetition: 0-100%, lower is better (hallucination detector) - invert
            if (metrics.repetition !== undefined && noRefWeights.repetition > 0) {
              const val = Math.max(0, 100 - (parseFloat(metrics.repetition) || 0));
              weightedSum += val * noRefWeights.repetition;
              totalWeight += noRefWeights.repetition;
            }
            
            // Number Preservation: 0-100%, higher is better - use as is
            if (metrics.numberPres !== undefined && noRefWeights.numberPres > 0) {
              const val = parseFloat(metrics.numberPres) || 0;
              weightedSum += val * noRefWeights.numberPres;
              totalWeight += noRefWeights.numberPres;
            }
            
            // Copy Rate: optimal 5-25% (some copying is normal for names, numbers)
            // 0% ‚Üí 70, 5-25% ‚Üí 100, 50% ‚Üí 50, 75% ‚Üí 0
            if (metrics.copyRate !== undefined && noRefWeights.copyRate > 0) {
              const copyVal = parseFloat(metrics.copyRate) || 0;
              let score = 100;
              if (copyVal < 5) score = 70 + copyVal * 6;
              else if (copyVal <= 25) score = 100;
              else score = Math.max(0, 100 - (copyVal - 25) * 2);
              weightedSum += score * noRefWeights.copyRate;
              totalWeight += noRefWeights.copyRate;
            }
            
            // Length Ratio: optimal at 100% - penalize deviation
            if (metrics.lengthRatio !== undefined && noRefWeights.lengthRatio > 0) {
              const ratio = parseFloat(metrics.lengthRatio) || 100;
              const deviation = Math.abs(ratio - 100);
              const score = Math.max(0, 100 - deviation * 2);
              weightedSum += score * noRefWeights.lengthRatio;
              totalWeight += noRefWeights.lengthRatio;
            }
            
            // LLM Score: 1-10 scale, higher is better - convert to 0-100
            // 1 ‚Üí 0, 5.5 ‚Üí 50, 10 ‚Üí 100
            if (metrics.score !== undefined && metrics.score !== 'N/A' && noRefWeights.llmScore > 0) {
              const rawScore = parseFloat(metrics.score) || 1;
              const val = Math.max(0, Math.min(100, (rawScore - 1) * 100 / 9));
              weightedSum += val * noRefWeights.llmScore;
              totalWeight += noRefWeights.llmScore;
            }
            
            // COMET-QE: z-score scale (-0.5 to 0.5 typical), normalize to 0-100
            // Map: -0.5 -> 0, 0.0 -> 50, 0.5 -> 100
            if (metrics.cometQE !== undefined && metrics.cometQE !== 'N/A' && noRefWeights.cometQE > 0) {
              const raw = parseFloat(metrics.cometQE) || 0;
              const val = Math.min(100, Math.max(0, (raw + 0.5) * 100));
              weightedSum += val * noRefWeights.cometQE;
              totalWeight += noRefWeights.cometQE;
            }
            
            if (totalWeight === 0) return "N/A";
            return (weightedSum / totalWeight).toFixed(1);
          };

          // ==================== PYTHON BACKEND FOR NEURAL METRICS ====================
          
          const calculateBERTScore = async (reference, candidate, lang = 'en') => {
            try {
              const response = await fetch(`${pythonBackendUrl}/bertscore`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reference, candidate, lang })
              });
              if (!response.ok) throw new Error('BERTScore backend error');
              const data = await response.json();
              return {
                precision: (data.precision * 100).toFixed(2),
                recall: (data.recall * 100).toFixed(2),
                f1: (data.f1 * 100).toFixed(2)
              };
            } catch (error) {
              console.error('BERTScore error:', error);
              return null;
            }
          };
          
          // Call Python backend for COMET
          const calculateCOMET = async (source, reference, candidate) => {
            try {
              const response = await fetch(`${pythonBackendUrl}/comet`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ source, reference, candidate })
              });
              if (!response.ok) throw new Error('COMET backend error');
              const data = await response.json();
              return data.score.toFixed(4);
            } catch (error) {
              console.error('COMET error:', error);
              return null;
            }
          };
          
          // Call Python backend for COMET-QE (no reference needed)
          const calculateCOMETQE = async (source, candidate) => {
            try {
              const response = await fetch(`${pythonBackendUrl}/comet-qe`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ source, candidate })
              });
              if (!response.ok) throw new Error('COMET-QE backend error');
              const data = await response.json();
              return data.score.toFixed(4);
            } catch (error) {
              console.error('COMET-QE error:', error);
              return null;
            }
          };
          
          // Call Python backend for BLEURT
          const calculateBLEURT = async (reference, candidate) => {
            try {
              const response = await fetch(`${pythonBackendUrl}/bleurt`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reference, candidate })
              });
              if (!response.ok) throw new Error('BLEURT backend error');
              const data = await response.json();
              return data.score.toFixed(4);
            } catch (error) {
              console.error('BLEURT error:', error);
              return null;
            }
          };
          
          // Batch call for neural metrics (more efficient)
          const calculateNeuralMetricsBatch = async (pairs, metricsToCalc) => {
            try {
              const response = await fetch(`${pythonBackendUrl}/batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ pairs, metrics: metricsToCalc })
              });
              if (!response.ok) throw new Error('Batch neural metrics error');
              return await response.json();
            } catch (error) {
              console.error('Batch neural metrics error:', error);
              return null;
            }
          };

          // Jaccard Similarity
          const calculateJaccard = (reference, candidate) => {
            const refSet = new Set(tokenize(reference));
            const candSet = new Set(tokenize(candidate));
            
            const intersection = new Set([...refSet].filter(x => candSet.has(x)));
            const union = new Set([...refSet, ...candSet]);
            
            return union.size > 0 ? ((intersection.size / union.size) * 100).toFixed(2) : "0.00";
          };

          // Length Ratio
          const calculateLengthRatio = (reference, candidate) => {
            if (reference.length === 0) return "0.00";
            return ((candidate.length / reference.length) * 100).toFixed(2);
          };
          
          // chrF Score (character n-gram F-score)
          const calculateChrF = (reference, candidate) => {
            const refChars = reference.split('');
            const candChars = candidate.split('');
            
            let totalMatches = 0;
            let totalRef = 0;
            let totalCand = 0;
            
            // Calculate for n=1 to n=6 character n-grams
            for (let n = 1; n <= 6; n++) {
              const refNgrams = {};
              const candNgrams = {};
              
              for (let i = 0; i <= refChars.length - n; i++) {
                const ngram = refChars.slice(i, i + n).join('');
                refNgrams[ngram] = (refNgrams[ngram] || 0) + 1;
              }
              
              for (let i = 0; i <= candChars.length - n; i++) {
                const ngram = candChars.slice(i, i + n).join('');
                candNgrams[ngram] = (candNgrams[ngram] || 0) + 1;
              }
              
              let matches = 0;
              for (const ngram in candNgrams) {
                if (refNgrams[ngram]) {
                  matches += Math.min(candNgrams[ngram], refNgrams[ngram]);
                }
              }
              
              totalMatches += matches;
              totalRef += Object.values(refNgrams).reduce((a, b) => a + b, 0);
              totalCand += Object.values(candNgrams).reduce((a, b) => a + b, 0);
            }
            
            const precision = totalCand > 0 ? totalMatches / totalCand : 0;
            const recall = totalRef > 0 ? totalMatches / totalRef : 0;
            const fScore = (precision + recall) > 0 ? (2 * precision * recall) / (precision + recall) : 0;
            
            return (fScore * 100).toFixed(2);
          };

          // ==================== NO-REFERENCE METRICS ====================
          
          // Repetition Ratio - detects hallucinations (repeated n-grams)
          const calculateRepetitionRatio = (text) => {
            const tokens = tokenize(text);
            if (tokens.length < 4) return "0.00";
            
            const bigrams = [];
            for (let i = 0; i < tokens.length - 1; i++) {
              bigrams.push(tokens[i] + tokens[i + 1]);
            }
            
            const bigramCounts = {};
            bigrams.forEach(bg => {
              bigramCounts[bg] = (bigramCounts[bg] || 0) + 1;
            });
            
            const repeated = Object.values(bigramCounts).filter(c => c > 1).reduce((a, b) => a + b, 0);
            return ((repeated / bigrams.length) * 100).toFixed(2);
          };

          // Sentence Count comparison
          const calculateSentenceCount = (original, translation) => {
            const countSentences = (text) => {
              const matches = text.match(/[.!?„ÄÇÔºüÔºÅ]+/g);
              return matches ? matches.length : 1;
            };
            
            const origCount = countSentences(original);
            const transCount = countSentences(translation);
            
            return { original: origCount, translation: transCount, match: origCount === transCount };
          };

          // Number Preservation - checks if numbers are preserved
          const calculateNumberPreservation = (original, translation) => {
            const extractNumbers = (text) => {
              const matches = text.match(/\d+([.,]\d+)?/g) || [];
              return matches.map(n => n.replace(',', '.')).sort();
            };
            
            const origNums = extractNumbers(original);
            const transNums = extractNumbers(translation);
            
            if (origNums.length === 0) return { preserved: 100, missing: 0, extra: transNums.length };
            
            let preserved = 0;
            const transCopy = [...transNums];
            
            origNums.forEach(num => {
              const idx = transCopy.indexOf(num);
              if (idx !== -1) {
                preserved++;
                transCopy.splice(idx, 1);
              }
            });
            
            return {
              preserved: ((preserved / origNums.length) * 100).toFixed(1),
              missing: origNums.length - preserved,
              extra: transCopy.length
            };
          };

          // Copy Rate - % of tokens copied from original (suspicious if >30%)
          // For CJK: uses character-level comparison
          // For alphabetic: uses words with length >= 3
          const calculateCopyRate = (original, translation) => {
            if (isCJK(original) || isCJK(translation)) {
              // For CJK: use 2-gram characters for comparison
              const getCharBigrams = (text) => {
                const chars = [...text.toLowerCase()].filter(c => 
                  /[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF]/.test(c)
                );
                const bigrams = new Set();
                for (let i = 0; i < chars.length - 1; i++) {
                  bigrams.add(chars[i] + chars[i + 1]);
                }
                return bigrams;
              };
              
              const origBigrams = getCharBigrams(original);
              const transBigrams = getCharBigrams(translation);
              
              if (transBigrams.size === 0) return "0.00";
              
              let copied = 0;
              transBigrams.forEach(bg => {
                if (origBigrams.has(bg)) copied++;
              });
              
              return ((copied / transBigrams.size) * 100).toFixed(2);
            } else {
              // For alphabetic languages: use words >= 3 chars
              const origWords = new Set((original.toLowerCase().match(/\b\w{3,}\b/g) || []));
              const transWords = translation.toLowerCase().match(/\b\w{3,}\b/g) || [];
              
              if (transWords.length === 0) return "0.00";
              
              const copied = transWords.filter(w => origWords.has(w)).length;
              return ((copied / transWords.length) * 100).toFixed(2);
            }
          };

          // Character count and word/token count
          const calculateBasicStats = (text) => {
            return {
              charCount: text.length,
              charNoSpace: text.replace(/\s/g, '').length,
              wordCount: tokenize(text).length,
              sentenceCount: (text.match(/[.!?„ÄÇÔºüÔºÅ]+/g) || []).length || 1
            };
          };

          const runReferenceEvaluation = async () => {
            if (evalData.length === 0) {
              alert('Please load a JSON file first');
              return;
            }

            // Clear previous results before starting new evaluation
            setEvalResults([]);

            console.log(`üîç Starting reference evaluation for ${evalData.length} rows`);
            console.log('üìã First row columns:', Object.keys(evalData[0]));

            setIsEvaluating(true);
            shouldStopRef.current = false;
            const results = [];

            try {
              for (const row of evalData) {
                if (shouldStopRef.current) {
                  console.log('‚èπÔ∏è Evaluation stopped by user');
                  break;
                }
                
                const original = row['Original'];
                // Check multiple possible column names for reference translation
                const reference = row['Reference Translation'] || row['Perfect Translation'] || row['Reference'] || row['Perfect'];
                const fromLang = row['From'];
                const toLang = row['To'];

                if (!original) {
                  console.log('‚ö†Ô∏è Skipping row - missing original');
                  continue;
                }
                
                console.log(`\nüìù Processing row:`);
                console.log(`  Original: "${original.substring(0, 50)}..."`);
                console.log(`  Reference: "${reference ? reference.substring(0, 50) + '...' : 'MISSING'}"`);
                console.log(`  From: ${fromLang}, To: ${toLang}`);
                
                if (!reference) {
                  console.log('‚ö†Ô∏è Skipping row - missing reference translation. Tried columns: Reference Translation, Perfect Translation, Reference, Perfect');
                  console.log('   Available columns:', Object.keys(row).join(', '));
                  continue;
                }

                const rowResult = {
                  original,
                  reference,
                  fromLang,
                  toLang,
                  evaluations: {}
                };

                // Evaluate each model's translation
                let modelsFound = 0;
                for (const [key, value] of Object.entries(row)) {
                  // Skip metadata columns and time/cost columns
                  if (['Original', 'Reference Translation', 'Reference', 'Perfect Translation', 'Perfect', 
                       'From', 'To', 'System Prompt', 'Timestamp'].includes(key)) {
                    continue;
                  }
                  // Skip time and cost columns
                  if (key.includes(' - Time (s)') || key.includes(' - Cost ($)')) {
                    continue;
                  }
                  if (!value || value === 'N/A' || value === '' || typeof value !== 'string') {
                    continue;
                  }

                  modelsFound++;
                  console.log(`  ü§ñ Evaluating model: ${key}`);

                  try {
                    const metrics = {
                      translation: value
                    };
                    
                    // Detect language for METEOR synonyms
                    const lang = (toLang || '').toLowerCase().startsWith('de') ? 'de' : 
                                 (toLang || '').toLowerCase().startsWith('ru') ? 'ru' : 'en';
                    
                    // Calculate only selected metrics
                    if (evalMethods.bleu) {
                      metrics.bleu = calculateBLEU(reference, value);
                    }
                    if (evalMethods.meteor) {
                      metrics.meteor = calculateMETEOR(reference, value, lang);
                    }
                    if (evalMethods.cer) {
                      metrics.cer = calculateCER(reference, value);
                    }
                    if (evalMethods.wer) {
                      metrics.wer = calculateWER(reference, value);
                    }
                    if (evalMethods.jaccard) {
                      metrics.jaccard = calculateJaccard(reference, value);
                    }
                    if (evalMethods.chrf) {
                      metrics.chrF = calculateChrF(reference, value);
                    }
                    if (evalMethods.lengthRatio) {
                      metrics.lengthRatio = calculateLengthRatio(reference, value);
                    }
                    
                    // Neural metrics (require Python backend)
                    if (evalMethods.bertScore) {
                      console.log(`     üìä Calculating BERTScore...`);
                      const bertResult = await calculateBERTScore(reference, value, lang);
                      if (bertResult) {
                        metrics.bertScore = bertResult.f1;
                        metrics.bertP = bertResult.precision;
                        metrics.bertR = bertResult.recall;
                      } else {
                        metrics.bertScore = 'N/A';
                      }
                    }
                    if (evalMethods.comet) {
                      console.log(`     üìä Calculating COMET...`);
                      const cometScore = await calculateCOMET(original, reference, value);
                      metrics.comet = cometScore || 'N/A';
                    }
                    if (evalMethods.bleurt) {
                      console.log(`     üìä Calculating BLEURT...`);
                      const bleurtScore = await calculateBLEURT(reference, value);
                      metrics.bleurt = bleurtScore || 'N/A';
                    }
                    
                    // Calculate Total Score
                    metrics.total = calculateTotalScore(metrics);
                    
                    // Extract time and cost from JSON if available
                    const timeKey = `${key} - Time (s)`;
                    const costKey = `${key} - Cost ($)`;
                    if (row[timeKey] !== undefined) {
                      metrics.time = parseFloat(row[timeKey]) * 1000; // Convert to ms
                    }
                    if (row[costKey] !== undefined) {
                      metrics.cost = parseFloat(row[costKey]) * 100; // Convert to cents
                    }
                    
                    rowResult.evaluations[key] = metrics;
                    console.log(`     ‚úÖ Metrics calculated`);
                  } catch (error) {
                    console.error(`‚ùå Error calculating metrics for ${key}:`, error);
                    const errorMetrics = { translation: value };
                    if (evalMethods.bleu) errorMetrics.bleu = 'Error';
                    if (evalMethods.meteor) errorMetrics.meteor = 'Error';
                    if (evalMethods.cer) errorMetrics.cer = 'Error';
                    if (evalMethods.wer) errorMetrics.wer = 'Error';
                    if (evalMethods.jaccard) errorMetrics.jaccard = 'Error';
                    if (evalMethods.chrf) errorMetrics.chrF = 'Error';
                    if (evalMethods.lengthRatio) errorMetrics.lengthRatio = 'Error';
                    errorMetrics.total = 'Error';
                    rowResult.evaluations[key] = errorMetrics;
                  }
                }
                
                console.log(`  üìä Found ${modelsFound} models to evaluate`);

                if (modelsFound > 0) {
                  results.push(rowResult);
                  setEvalResults([...results]);
                } else {
                  console.log('‚ö†Ô∏è No model translations found in this row');
                }
              }

              setIsEvaluating(false);
              console.log(`‚úÖ Evaluated ${results.length} translations`);
            } catch (error) {
              console.error('‚ùå Error in reference evaluation:', error);
              alert(`Error during evaluation: ${error.message}`);
              setIsEvaluating(false);
            }
          };

          // LLM-as-a-Judge evaluation (no reference needed)
          const evaluateWithLLM = async (original, translation, fromLang, toLang, evaluatorKey) => {
            const startTime = Date.now();
            
            // Check if we have a valid evaluator API key
            const hasEvaluatorKey = evaluatorKey && evaluatorKey.trim() !== '';
            
            if (!hasEvaluatorKey) {
              return null; // Return null to skip LLM evaluation
            }

            const evaluatorPrompt = `You are a professional translation quality evaluator. Evaluate the following translation on a scale of 1-10 for:
1. Fluency (grammar, naturalness, readability)
2. Adequacy (meaning preservation, completeness)
3. Overall quality

Original text (${fromLang}):
${original}

Translation (${toLang}):
${translation}

Respond ONLY with a valid JSON object in this exact format (no other text):
{
  "fluency": 8.5,
  "adequacy": 9.0,
  "overall": 8.7,
  "feedback": "Brief explanation of the scores"
}`;

            try {
              let res, data, usage;
              // Try to detect which API to use based on key format
              const isAnthropicKey = evaluatorKey.startsWith('sk-ant-');
              
              if (isAnthropicKey) {
                const model = availableModels.find(m => m.id === evaluatorModel);
                if (!model) {
                  throw new Error(`Evaluator model ${evaluatorModel} not found`);
                }
                res = await fetch("/translate/anthropic", {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json"
                  },
                  body: JSON.stringify({
                    text: evaluatorPrompt,
                    api_key: evaluatorKey,
                    model: model.model,
                    system_prompt: "You are a professional translation quality evaluator.",
                    temperature: 0.3,
                    max_tokens: 1000
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                data = await res.json();
                usage = data.usage;
                let responseText = data.translation || '';
                
                if (!responseText) {
                  throw new Error('Empty response from evaluator');
                }
                
                // Clean up response - remove markdown code blocks if present
                responseText = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                
                const evaluation = JSON.parse(responseText);
                const cost = calculateCost(model, evaluatorPrompt, responseText, usage);
                
                return {
                  score: evaluation.overall?.toFixed(1) || 'N/A',
                  fluency: evaluation.fluency?.toFixed(1) || 'N/A',
                  adequacy: evaluation.adequacy?.toFixed(1) || 'N/A',
                  feedback: evaluation.feedback || '',
                  time: timeMs,
                  cost: cost
                };
              } else {
                // Assume OpenAI or DeepSeek key if not Anthropic
                const isDeepSeekKey = evaluatorModel.includes('deepseek');
                const modelName = isDeepSeekKey ? evaluatorModel : 'gpt-4o';
                
                res = await fetch(isDeepSeekKey ? '/translate/deepseek' : '/translate/openai', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    text: evaluatorPrompt,
                    api_key: evaluatorKey,
                    model: modelName,
                    system_prompt: "You are a professional translation quality evaluator.",
                    temperature: 0.3,
                    max_tokens: 1000
                  })
                });
                
                const endTime = Date.now();
                const timeMs = endTime - startTime;
                
                data = await res.json();
                usage = data.usage;
                let responseText = data.translation || '';
                
                if (!responseText) {
                  throw new Error('Empty response from evaluator');
                }
                
                responseText = responseText.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                
                const evaluation = JSON.parse(responseText);
                const pseudoModel = { provider: isDeepSeekKey ? 'deepseek' : 'openai', model: modelName, id: modelName };
                const cost = calculateCost(pseudoModel, evaluatorPrompt, responseText, usage);
                
                return {
                  score: evaluation.overall?.toFixed(1) || 'N/A',
                  fluency: evaluation.fluency?.toFixed(1) || 'N/A',
                  adequacy: evaluation.adequacy?.toFixed(1) || 'N/A',
                  feedback: evaluation.feedback || '',
                  time: timeMs,
                  cost: cost
                };
              }
            } catch (error) {
              console.error('LLM evaluation error:', error);
              return {
                score: 'Error',
                fluency: 'Error',
                adequacy: 'Error',
                feedback: `Error: ${error.message}`,
                time: Date.now() - startTime,
                cost: 0
              };
            }
          };

          const runNoReferenceEvaluation = async () => {
            if (evalData.length === 0) {
              alert('Please load a JSON file first');
              return;
            }

            // Clear previous results before starting new evaluation
            setEvalResults([]);

            setIsEvaluating(true);
            shouldStopRef.current = false;
            const results = [];

            try {
              for (let i = 0; i < evalData.length; i++) {
                if (shouldStopRef.current) {
                  console.log('‚èπÔ∏è Evaluation stopped by user');
                  break;
                }
                
                const row = evalData[i];
                const original = row['Original'];
                const fromLang = row['From'];
                const toLang = row['To'];
                
                // Get reference translation if available
                const reference = row['Reference Translation'] || row['Perfect Translation'] || 
                                 row['Reference'] || row['Perfect'] || row['reference'];

                if (!original) {
                  console.log(`Skipping row ${i + 1} - missing original`);
                  continue;
                }

                const rowResult = {
                  original,
                  reference: reference || null,
                  fromLang,
                  toLang,
                  evaluations: {}
                };

                // Helper function to evaluate a translation with all enabled metrics
                const evaluateTranslation = async (translationText, modelName, isReference = false) => {
                  const metrics = {
                    translation: translationText,
                    _isReference: isReference
                  };

                  // Basic metrics (if enabled)
                  if (evalMethods.basicMetrics) {
                    metrics.lengthRatio = calculateLengthRatio(original, translationText);
                    metrics.jaccard = calculateJaccard(original, translationText);
                    metrics.charCount = translationText.length;
                    metrics.wordCount = tokenize(translationText).length;
                  }
                  
                  // No-reference quality metrics
                  if (evalMethods.repetition) {
                    metrics.repetition = calculateRepetitionRatio(translationText);
                  }
                  if (evalMethods.numberPres) {
                    const numPres = calculateNumberPreservation(original, translationText);
                    metrics.numberPres = numPres.preserved;
                  }
                  if (evalMethods.copyRate) {
                    metrics.copyRate = calculateCopyRate(original, translationText);
                  }
                  if (evalMethods.sentenceCount) {
                    const sentAlign = calculateSentenceCount(original, translationText);
                    metrics.sentOrig = sentAlign.original;
                    metrics.sentTrans = sentAlign.translation;
                    metrics.sentMatch = sentAlign.match ? '‚úì' : '‚úó';
                  }

                  // LLM-as-a-Judge evaluation (if enabled and API key provided)
                  if (evalMethods.llmJudge) {
                    console.log(`Evaluating ${modelName} with LLM (${i + 1}/${evalData.length})...`);
                    const llmEval = await evaluateWithLLM(original, translationText, fromLang, toLang, evaluatorApiKey);
                    if (llmEval) {
                      Object.assign(metrics, llmEval);
                    } else {
                      metrics.score = 'N/A';
                      metrics.fluency = 'N/A';
                      metrics.adequacy = 'N/A';
                      metrics.feedback = 'No evaluator API key provided';
                    }
                  }
                  
                  // COMET-QE (Neural metric without reference)
                  if (evalMethods.cometQE) {
                    console.log(`Calculating COMET-QE for ${modelName}...`);
                    const cometQEScore = await calculateCOMETQE(original, translationText);
                    metrics.cometQE = cometQEScore || 'N/A';
                  }
                  
                  // Calculate No-Reference Total Score
                  metrics.total = calculateNoRefTotalScore(metrics);
                  
                  return metrics;
                };

                // Evaluate Reference translation if available (same metrics as other translations)
                if (reference && reference.trim() !== '') {
                  try {
                    console.log(`üìö Evaluating Reference (${i + 1}/${evalData.length})...`);
                    const refMetrics = await evaluateTranslation(reference, 'üìö Reference', true);
                    rowResult.evaluations['üìö Reference'] = refMetrics;
                  } catch (error) {
                    console.error('Error evaluating Reference:', error);
                    rowResult.evaluations['üìö Reference'] = {
                      translation: reference,
                      _isReference: true,
                      error: error.message
                    };
                  }
                }

                // Evaluate each model's translation
                for (const [key, value] of Object.entries(row)) {
                  // Skip metadata columns
                  if (['Original', 'Reference Translation', 'Reference', 'Perfect Translation', 'Perfect', 
                       'reference', 'From', 'To', 'System Prompt', 'Timestamp', 'sourceLang', 'targetLang',
                       'original', 'systemPrompt', 'translations'].includes(key)) {
                    continue;
                  }
                  // Skip time and cost columns (we'll extract them separately)
                  if (key.includes(' - Time (s)') || key.includes(' - Cost ($)') || 
                      key.includes('time') || key.includes('cost')) {
                    continue;
                  }
                  if (!value || value === 'N/A' || value === '' || typeof value !== 'string') {
                    continue;
                  }

                  try {
                    const metrics = await evaluateTranslation(value, key, false);
                    
                    // Extract time and cost from JSON if available
                    const timeKey = `${key} - Time (s)`;
                    const costKey = `${key} - Cost ($)`;
                    if (row[timeKey] !== undefined) {
                      metrics.time = parseFloat(row[timeKey]) * 1000; // Convert to ms
                    }
                    if (row[costKey] !== undefined) {
                      metrics.cost = parseFloat(row[costKey]) * 100; // Convert to cents
                    }
                    
                    rowResult.evaluations[key] = metrics;
                  } catch (error) {
                    console.error(`Error evaluating ${key}:`, error);
                    const errorMetrics = { translation: value };
                    if (evalMethods.basicMetrics) {
                      errorMetrics.lengthRatio = 'Error';
                      errorMetrics.jaccard = 'Error';
                      errorMetrics.charCount = value.length;
                      errorMetrics.wordCount = 0;
                    }
                    if (evalMethods.llmJudge) {
                      errorMetrics.score = 'Error';
                      errorMetrics.fluency = 'Error';
                      errorMetrics.adequacy = 'Error';
                      errorMetrics.feedback = `Error: ${error.message}`;
                    }
                    rowResult.evaluations[key] = errorMetrics;
                  }
                }

                results.push(rowResult);
                setEvalResults([...results]);
              }

              setIsEvaluating(false);
              console.log(`‚úÖ Evaluated ${results.length} translations with LLM judge`);
            } catch (error) {
              console.error('Error in no-reference evaluation:', error);
              alert(`Error during evaluation: ${error.message}`);
              setIsEvaluating(false);
            }
          };

          // ==================== METRICS INFO & COLORING ====================
          
          const metricsInfo = {
            bleu: {
              name: 'BLEU',
              description: 'Higher is better',
              betterDirection: 'higher', // higher values are better
              excellent: 60,
              good: 40,
              poor: 20
            },
            meteor: {
              name: 'METEOR',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 50,
              good: 30,
              poor: 15
            },
            total: {
              name: 'Total',
              description: 'Weighted combination - Higher is better',
              betterDirection: 'higher',
              excellent: 70,
              good: 50,
              poor: 30
            },
            cer: {
              name: 'CER',
              description: 'Lower is better',
              betterDirection: 'lower', // lower values are better
              excellent: 10,
              good: 20,
              poor: 30
            },
            wer: {
              name: 'WER',
              description: 'Lower is better',
              betterDirection: 'lower',
              excellent: 15,
              good: 30,
              poor: 50
            },
            jaccard: {
              name: 'Jaccard',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 75,
              good: 60,
              poor: 40
            },
            chrF: {
              name: 'chrF',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 75,
              good: 60,
              poor: 40
            },
            lengthRatio: {
              name: 'Length Ratio',
              description: 'Closer to 100% is better',
              betterDirection: 'optimal', // optimal at 100%
              excellent: [90, 110], // range
              good: [80, 120],
              poor: [70, 130]
            },
            // No-reference metrics
            repetition: {
              name: 'Repetition',
              description: 'Lower is better (hallucination detector)',
              betterDirection: 'lower',
              excellent: 5,
              good: 15,
              poor: 25
            },
            numberPres: {
              name: 'Numbers',
              description: 'Higher is better (100% = all preserved)',
              betterDirection: 'higher',
              excellent: 100,
              good: 80,
              poor: 50
            },
            copyRate: {
              name: 'Copy Rate',
              description: 'Context-dependent (usually lower is better)',
              betterDirection: 'optimal',
              excellent: [5, 25],
              good: [0, 35],
              poor: [0, 50]
            },
            // Neural metrics
            bertScore: {
              name: 'BERTScore',
              description: 'Semantic similarity - Higher is better',
              betterDirection: 'higher',
              excellent: 90,
              good: 80,
              poor: 70
            },
            comet: {
              name: 'COMET',
              description: 'Neural MT metric - Higher is better',
              betterDirection: 'higher',
              excellent: 0.85,
              good: 0.75,
              poor: 0.60
            },
            bleurt: {
              name: 'BLEURT',
              description: 'Google metric - Higher is better',
              betterDirection: 'higher',
              excellent: 0.7,
              good: 0.5,
              poor: 0.3
            },
            cometQE: {
              name: 'COMET-QE',
              description: 'Quality Estimation - Higher is better',
              betterDirection: 'higher',
              excellent: 0.3,
              good: 0.2,
              poor: 0.0
            },
            // LLM metrics
            score: {
              name: 'Overall',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 8.5,
              good: 7.0,
              poor: 5.0
            },
            fluency: {
              name: 'Fluency',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 8.5,
              good: 7.0,
              poor: 5.0
            },
            adequacy: {
              name: 'Adequacy',
              description: 'Higher is better',
              betterDirection: 'higher',
              excellent: 8.5,
              good: 7.0,
              poor: 5.0
            }
          };

          // Get color class based on metric value (lighter = better)
          const getMetricColorClass = (metricKey, value) => {
            if (value === 'N/A' || value === 'Error' || value === undefined) {
              return 'bg-gray-100 text-gray-500';
            }

            const info = metricsInfo[metricKey];
            if (!info) return 'bg-gray-100 text-gray-700';

            const numValue = parseFloat(value);
            
            if (info.betterDirection === 'higher') {
              // Higher is better: excellent = dark/vibrant, poor = light/pale
              if (numValue >= info.excellent) {
                return 'bg-green-600 text-white'; // Excellent - dark green
              } else if (numValue >= info.good) {
                return 'bg-green-400 text-white'; // Good - medium green
              } else if (numValue >= info.poor) {
                return 'bg-yellow-200 text-gray-800'; // Fair - light yellow
              } else {
                return 'bg-red-200 text-gray-800'; // Poor - light red
              }
            } else if (info.betterDirection === 'lower') {
              // Lower is better: excellent = dark/vibrant, poor = light/pale
              if (numValue <= info.excellent) {
                return 'bg-green-600 text-white'; // Excellent - dark green
              } else if (numValue <= info.good) {
                return 'bg-green-400 text-white'; // Good - medium green
              } else if (numValue <= info.poor) {
                return 'bg-yellow-200 text-gray-800'; // Fair - light yellow
              } else {
                return 'bg-red-200 text-gray-800'; // Poor - light red
              }
            } else if (info.betterDirection === 'optimal') {
              // Optimal at 100%
              const distance = Math.abs(numValue - 100);
              if (distance <= 10) {
                return 'bg-green-600 text-white'; // Excellent
              } else if (distance <= 20) {
                return 'bg-green-400 text-white'; // Good
              } else if (distance <= 30) {
                return 'bg-yellow-200 text-gray-800'; // Fair
              } else {
                return 'bg-red-200 text-gray-800'; // Poor
              }
            }

            return 'bg-gray-100 text-gray-700';
          };

          // Calculate statistics across all results
          const calculateStatistics = () => {
            if (evalResults.length === 0) return null;

            const modelStats = {};
            
            evalResults.forEach((result) => {
              Object.entries(result.evaluations).forEach(([model, metrics]) => {
                if (!modelStats[model]) {
                  modelStats[model] = {
                    // Reference-based metrics
                    bleu: [],
                    meteor: [],
                    total: [],
                    cer: [],
                    wer: [],
                    jaccard: [],
                    chrF: [],
                    lengthRatio: [],
                    // Neural metrics
                    bertScore: [],
                    comet: [],
                    bleurt: [],
                    cometQE: [],
                    // LLM metrics
                    score: [],
                    fluency: [],
                    adequacy: [],
                    // No-reference quality metrics
                    repetition: [],
                    numberPres: [],
                    copyRate: [],
                    // Time & Cost
                    time: [],
                    cost: []
                  };
                }
                
                // Collect all numeric values
                Object.keys(modelStats[model]).forEach(key => {
                  const value = metrics[key];
                  if (value !== undefined && value !== 'N/A' && value !== 'Error' && !isNaN(parseFloat(value))) {
                    modelStats[model][key].push(parseFloat(value));
                  }
                });
                
                // Debug time specifically
                if (metrics.time !== undefined) {
                  console.log(`‚è±Ô∏è Time for ${model}: ${metrics.time}ms`);
                }
              });
            });

            // Calculate averages, min, max, std deviation
            const averages = {};
            Object.entries(modelStats).forEach(([model, metrics]) => {
              averages[model] = {};
              Object.entries(metrics).forEach(([metric, values]) => {
                if (values.length > 0) {
                  const sum = values.reduce((a, b) => a + b, 0);
                  const avg = sum / values.length;
                  const min = Math.min(...values);
                  const max = Math.max(...values);
                  
                  // Standard deviation
                  const squaredDiffs = values.map(v => Math.pow(v - avg, 2));
                  const avgSquaredDiff = squaredDiffs.reduce((a, b) => a + b, 0) / values.length;
                  const std = Math.sqrt(avgSquaredDiff);
                  
                  if (metric === 'time') {
                    // Time is in ms, convert to seconds
                    const sumSec = sum / 1000;
                    const avgSec = avg / 1000;
                    averages[model][metric + '_total'] = sumSec.toFixed(2);
                    averages[model][metric] = avgSec.toFixed(2);
                  } else if (metric === 'cost') {
                    // Cost is in cents, convert to dollars
                    const sumDollars = sum / 100;
                    const avgDollars = avg / 100;
                    averages[model][metric + '_total'] = sumDollars.toFixed(4);
                    averages[model][metric] = avgDollars.toFixed(4);
                  } else {
                    averages[model][metric] = avg.toFixed(2);
                    averages[model][metric + '_min'] = min.toFixed(2);
                    averages[model][metric + '_max'] = max.toFixed(2);
                    averages[model][metric + '_std'] = std.toFixed(2);
                  }
                }
              });
            });
            
            console.log('üìà Statistics calculated:', Object.entries(averages).map(([m, s]) => ({model: m, time_total: s.time_total, cost_total: s.cost_total, total: s.total, total_std: s.total_std})));

            return averages;
          };

          const exportEvalResults = () => {
            if (evalResults.length === 0) {
              alert('No evaluation results to export');
              return;
            }

            const data = evalResults.map(r => {
              const entry = {
                original: r.original,
                reference: r.reference || null,
                sourceLang: r.fromLang,
                targetLang: r.toLang,
                evaluations: {}
              };

              Object.entries(r.evaluations).forEach(([modelName, metrics]) => {
                entry.evaluations[modelName] = {
                  translation: metrics.translation,
                  time: metrics.time !== undefined ? metrics.time / 1000 : undefined,
                  cost: metrics.cost !== undefined ? metrics.cost / 100 : undefined,
                  // Reference-based metrics
                  bleu: metrics.bleu,
                  meteor: metrics.meteor,
                  total: metrics.total,
                  cer: metrics.cer,
                  wer: metrics.wer,
                  jaccard: metrics.jaccard,
                  chrF: metrics.chrF,
                  lengthRatio: metrics.lengthRatio,
                  // Neural metrics
                  bertScore: metrics.bertScore,
                  comet: metrics.comet,
                  bleurt: metrics.bleurt,
                  cometQE: metrics.cometQE,
                  // No-reference quality metrics
                  repetition: metrics.repetition,
                  numberPres: metrics.numberPres,
                  copyRate: metrics.copyRate,
                  // LLM metrics
                  llmScore: metrics.score,
                  fluency: metrics.fluency,
                  adequacy: metrics.adequacy,
                  charCount: metrics.charCount,
                  wordCount: metrics.wordCount,
                  feedback: metrics.feedback
                };
              });

              return entry;
            });

            console.log('üì• Exporting evaluation results to JSON:', data);
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `evaluation_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            console.log('‚úÖ Evaluation results exported to JSON');
          };

          // ==================== SHARED CHART COMPONENTS ====================
          
          // Color palette for companies
          const companyColors = {
            'Anthropic': '#D97706',
            'OpenAI': '#10B981',
            'DeepSeek': '#3B82F6',
            'DeepL': '#0052CC',
            'Google': '#EA4335',
            'Meta': '#1877F2',
            'Helsinki-NLP': '#FF6B35',
            'Open Source': '#6B7280',
            'Human': '#9333EA',
            'Unknown': '#9CA3AF'
          };
          
          // SVG Scatter Plot Component
          const ScatterPlot = ({ data, xKey, xLabel, yLabel, title, subtitle, xFormat, logScale }) => {
            const width = 600;
            const height = 400;
            const padding = { top: 40, right: 30, bottom: 60, left: 70 };
            const plotW = width - padding.left - padding.right;
            const plotH = height - padding.top - padding.bottom;
            
            const validData = data.filter(d => {
              if (xKey === 'releasedYear') return d[xKey] !== null && d[xKey] !== undefined;
              if (xKey === 'cost' || xKey === 'pricePerMToken') return d[xKey] >= 0; // Include free models
              return d[xKey] > 0; // time must be > 0
            });
            if (validData.length === 0) {
              const msg = xKey === 'cost' || xKey === 'pricePerMToken' ? 'No price data available.' :
                          xKey === 'time' ? 'No timing data. Run batch translation to collect timing info.' :
                          'No data available';
              return <p className="text-gray-500 text-sm p-4 italic">{msg}</p>;
            }
            
            const xValues = validData.map(d => d[xKey]);
            const yValues = validData.map(d => d.quality);
            
            let xMin, xMax;
            let scaleX;
            
            if (logScale && xValues.every(v => v > 0)) {
              // Log scale for model sizes (can vary by orders of magnitude)
              const logValues = xValues.map(v => Math.log10(v));
              const logMin = Math.min(...logValues);
              const logMax = Math.max(...logValues);
              const logPadding = (logMax - logMin) * 0.1 || 0.5;
              xMin = Math.pow(10, logMin - logPadding);
              xMax = Math.pow(10, logMax + logPadding);
              scaleX = (val) => {
                const logVal = Math.log10(val);
                const logMinP = Math.log10(xMin);
                const logMaxP = Math.log10(xMax);
                return padding.left + ((logVal - logMinP) / (logMaxP - logMinP)) * plotW;
              };
            } else {
              // Linear scale
              xMin = Math.min(...xValues);
              xMax = Math.max(...xValues);
              // Add padding to x axis
              const xPadding = (xMax - xMin) * 0.15 || (xMax * 0.2) || 0.1;
              xMin = Math.max(0, xMin - xPadding); // Never go below 0 for cost/time
              xMax = xMax + xPadding;
              scaleX = (val) => padding.left + ((val - xMin) / (xMax - xMin)) * plotW;
            }
            
            const yMin = Math.min(...yValues) * 0.9;
            const yMax = Math.max(...yValues) * 1.05;
            
            const scaleY = (val) => padding.top + plotH - ((val - yMin) / (yMax - yMin)) * plotH;
            
            // Grid lines
            const xTicks = 5;
            const yTicks = 5;
            
            return (
              <svg viewBox={`0 0 ${width} ${height}`} className="w-full max-w-2xl mx-auto">
                {/* Background */}
                <rect x={padding.left} y={padding.top} width={plotW} height={plotH} fill="#f9fafb" />
                
                {/* Grid lines */}
                {[...Array(yTicks + 1)].map((_, i) => {
                  const y = padding.top + (plotH / yTicks) * i;
                  const val = yMax - ((yMax - yMin) / yTicks) * i;
                  return (
                    <g key={`y-${i}`}>
                      <line x1={padding.left} y1={y} x2={width - padding.right} y2={y} stroke="#e5e7eb" strokeWidth="1" />
                      <text x={padding.left - 10} y={y + 4} textAnchor="end" fontSize="11" fill="#6b7280">{val.toFixed(0)}</text>
                    </g>
                  );
                })}
                {[...Array(xTicks + 1)].map((_, i) => {
                  const x = padding.left + (plotW / xTicks) * i;
                  let val;
                  if (logScale && xMin > 0) {
                    // Log scale: interpolate in log space
                    const logMin = Math.log10(xMin);
                    const logMax = Math.log10(xMax);
                    val = Math.pow(10, logMin + ((logMax - logMin) / xTicks) * i);
                  } else {
                    val = xMin + ((xMax - xMin) / xTicks) * i;
                  }
                  return (
                    <g key={`x-${i}`}>
                      <line x1={x} y1={padding.top} x2={x} y2={height - padding.bottom} stroke="#e5e7eb" strokeWidth="1" />
                      <text x={x} y={height - padding.bottom + 20} textAnchor="middle" fontSize="11" fill="#6b7280">
                        {xFormat ? xFormat(val) : val.toFixed(2)}
                      </text>
                    </g>
                  );
                })}
                
                {/* Axes */}
                <line x1={padding.left} y1={height - padding.bottom} x2={width - padding.right} y2={height - padding.bottom} stroke="#374151" strokeWidth="2" />
                <line x1={padding.left} y1={padding.top} x2={padding.left} y2={height - padding.bottom} stroke="#374151" strokeWidth="2" />
                
                {/* Axis labels */}
                <text x={width / 2} y={height - 10} textAnchor="middle" fontSize="13" fill="#374151" fontWeight="500">{xLabel}</text>
                <text x={20} y={height / 2} textAnchor="middle" fontSize="13" fill="#374151" fontWeight="500" transform={`rotate(-90, 20, ${height/2})`}>{yLabel}</text>
                
                {/* Data points */}
                {(() => {
                  // Calculate positions and detect overlaps
                  const positions = validData.map((d, i) => ({
                    d,
                    x: scaleX(d[xKey]),
                    y: scaleY(d.quality),
                    labelY: scaleY(d.quality) - 14,
                    color: d.isReference ? '#9333EA' : (companyColors[d.company] || '#6B7280')
                  }));
                  
                  // Sort by x position and adjust overlapping labels
                  positions.sort((a, b) => a.x - b.x);
                  for (let i = 1; i < positions.length; i++) {
                    const prev = positions[i - 1];
                    const curr = positions[i];
                    const xDist = Math.abs(curr.x - prev.x);
                    const yDist = Math.abs(curr.y - prev.y);
                    // If points are close, alternate label position
                    if (xDist < 60 && yDist < 30) {
                      curr.labelY = curr.y + 22; // Move below
                      curr.labelBelow = true;
                    }
                  }
                  
                  return positions.map((p, i) => (
                    <g key={i}>
                      {/* Point */}
                      <circle 
                        cx={p.x} 
                        cy={p.y} 
                        r={p.d.isReference ? 10 : 8} 
                        fill={p.color}
                        stroke="white"
                        strokeWidth="2"
                        style={{ cursor: 'pointer' }}
                      />
                      {/* Label with background for readability */}
                      <text 
                        x={p.x} 
                        y={p.labelY} 
                        textAnchor="middle" 
                        fontSize="9" 
                        fill="#374151"
                        fontWeight={p.d.isReference ? 'bold' : 'normal'}
                      >
                        {p.d.shortName || p.d.model.substring(0, 12)}
                      </text>
                    </g>
                  ));
                })()}
                
                {/* Title */}
                <text x={width / 2} y={20} textAnchor="middle" fontSize="14" fill="#1f2937" fontWeight="bold">{title}</text>
              </svg>
            );
          };

          // ==================== UI RENDERING ====================

          return (
            <div className="min-h-screen p-6">
              <div className="max-w-7xl mx-auto">
                <div className="bg-white rounded-2xl shadow-2xl overflow-hidden">
                  {/* Header */}
                  <div className="bg-gradient-to-r from-blue-600 to-indigo-600 p-6 text-white">
                    <h1 className="text-3xl font-bold">Advanced Translation Testing Suite</h1>
                    <p className="mt-2 text-blue-100">Professional translation quality assessment with multiple LLMs</p>
                  </div>

                  <div className="p-6 space-y-6">
                    {/* Mode Tabs */}
                    <div className="flex gap-2 border-b-2 pb-2">
                      <button
                        onClick={() => {
                          setMode('manual');
                          setEvalData([]);
                          setEvalResults([]);
                        }}
                        className={`px-6 py-3 font-semibold rounded-t-lg transition-colors ${
                          mode === 'manual' 
                            ? 'bg-blue-600 text-white' 
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        üìù Manual Translation
                      </button>
                      <button
                        onClick={() => {
                          setMode('test');
                          setEvalData([]);
                          setEvalResults([]);
                        }}
                        className={`px-6 py-3 font-semibold rounded-t-lg transition-colors ${
                          mode === 'test' 
                            ? 'bg-purple-600 text-white' 
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        üß™ Batch Testing
                      </button>
                      <button
                        onClick={() => {
                          setMode('eval-ref');
                          setEvalData([]);
                          setEvalResults([]);
                        }}
                        className={`px-6 py-3 font-semibold rounded-t-lg transition-colors ${
                          mode === 'eval-ref' 
                            ? 'bg-green-600 text-white' 
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        ‚úÖ Eval (with Reference)
                      </button>
                      <button
                        onClick={() => {
                          setMode('eval-noref');
                          setEvalData([]);
                          setEvalResults([]);
                        }}
                        className={`px-6 py-3 font-semibold rounded-t-lg transition-colors ${
                          mode === 'eval-noref' 
                            ? 'bg-orange-600 text-white' 
                            : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                        }`}
                      >
                        ü§ñ Eval without ref
                      </button>
                    </div>

                    {/* API Keys Section */}
                    {(mode === 'manual' || mode === 'test') && (
                    <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                      <h2 className="font-semibold mb-3 text-gray-700">üîë API Keys</h2>
                      <div className="grid grid-cols-2 gap-3">
                        {Object.keys(apiKeys).map(key => (
                          <div key={key}>
                            <label className="block text-xs font-medium text-gray-600 mb-1">
                              {key.charAt(0).toUpperCase() + key.slice(1)}
                            </label>
                            <input
                              type="password"
                              placeholder={`Enter ${key} API key`}
                              value={apiKeys[key]}
                              onChange={(e) => setApiKeys({...apiKeys, [key]: e.target.value})}
                              className="w-full px-3 py-2 border rounded-lg text-sm font-mono"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                    )}

                    {/* Models Selection */}
                    {(mode === 'manual' || mode === 'test') && (
                    <div className="bg-blue-50 p-4 rounded-lg border border-blue-200">
                      <div className="flex justify-between items-center mb-3">
                        <h2 className="font-semibold text-blue-900">
                          ü§ñ Translation Models ({selectedModels.length})
                        </h2>
                        <div className="flex gap-2">
                          <button
                            onClick={() => setSelectedModels(availableModels)}
                            className="px-3 py-1.5 text-xs bg-green-500 text-white rounded hover:bg-green-600"
                            title="Add all available models"
                          >
                            + All
                          </button>
                          <button
                            onClick={() => setSelectedModels([])}
                            className="px-3 py-1.5 text-xs bg-red-500 text-white rounded hover:bg-red-600"
                            title="Remove all models"
                          >
                            Clear
                          </button>
                          <select 
                            onChange={handleAddModel} 
                            value="" 
                            className="px-4 py-2 border rounded-lg bg-white text-sm font-medium hover:bg-gray-50"
                          >
                            <option value="">+ Add Model</option>
                            {availableModels
                              .filter(m => !selectedModels.find(sm => sm.id === m.id))
                              .map(m => (
                                <option key={m.id} value={m.id}>
                                  {m.name} ({m.cost} cost)
                                </option>
                              ))
                            }
                          </select>
                        </div>
                      </div>
                      <div className="flex flex-wrap gap-2">
                        {selectedModels.map(m => (
                          <div 
                            key={m.id} 
                            className="bg-white px-4 py-2 rounded-lg border border-blue-300 flex items-center gap-3 shadow-sm"
                          >
                            <span className="text-sm font-medium">{m.name}</span>
                            <span className="text-xs text-gray-500">({m.cost})</span>
                            <button 
                              onClick={() => handleRemoveModel(m.id)} 
                              className="text-red-500 hover:text-red-700 font-bold text-lg"
                            >
                              √ó
                            </button>
                          </div>
                        ))}
                        {selectedModels.length === 0 && (
                          <p className="text-gray-500 italic">No models selected. Click "+ Add Model" above.</p>
                        )}
                      </div>
                    </div>
                    )}

                    {/* MANUAL MODE */}
                    {mode === 'manual' && (
                      <>
                        <div className="bg-amber-50 p-4 rounded-lg border border-amber-200">
                          <h2 className="font-semibold mb-3 text-amber-900">‚öôÔ∏è Translation Settings</h2>
                          <div className="space-y-3">
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                System Prompt
                              </label>
                              <input
                                type="text"
                                value={systemPrompt}
                                onChange={(e) => setSystemPrompt(e.target.value)}
                                placeholder="You are a professional translator. Provide ONLY the translation."
                                className="w-full px-3 py-2 border rounded-lg"
                              />
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                Style Instructions
                              </label>
                              <textarea
                                value={styleInstructions}
                                onChange={(e) => setStyleInstructions(e.target.value)}
                                placeholder="Output ONLY the translated text. No explanations or notes."
                                className="w-full h-20 px-3 py-2 border rounded-lg resize-none"
                              />
                            </div>
                          </div>
                        </div>

                        <div>
                          <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">
                                Source Language
                              </label>
                              <select 
                                value={sourceLang} 
                                onChange={(e) => setSourceLang(e.target.value)} 
                                className="w-full px-3 py-2 border rounded-lg"
                              >
                                {languages.map(l => (
                                  <option key={l.code} value={l.code}>{l.name}</option>
                                ))}
                              </select>
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">
                                Target Language
                              </label>
                              <select 
                                value={targetLang} 
                                onChange={(e) => setTargetLang(e.target.value)} 
                                className="w-full px-3 py-2 border rounded-lg"
                              >
                                {languages.map(l => (
                                  <option key={l.code} value={l.code}>{l.name}</option>
                                ))}
                              </select>
                            </div>
                          </div>

                          <textarea
                            value={sourceText}
                            onChange={(e) => setSourceText(e.target.value)}
                            placeholder="Enter text to translate..."
                            className="w-full h-32 px-4 py-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500"
                          />

                          <div className="flex gap-3 mt-4">
                            <button
                              onClick={handleTranslate}
                              disabled={isTranslating || selectedModels.length === 0}
                              className="flex-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                            >
                              {isTranslating ? '‚è≥ Translating...' : 'üöÄ Translate'}
                            </button>
                            <button
                              onClick={exportToJSON}
                              disabled={translations.length === 0}
                              className="bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                            >
                              üì• Export JSON
                            </button>
                          </div>
                        </div>

                        {/* Translation History */}
                        {translations.length > 0 && (
                          <div>
                            <h2 className="text-xl font-semibold mb-4 text-gray-800">
                              üìö Translation History ({translations.length})
                            </h2>
                            <div className="space-y-4 max-h-[600px] overflow-y-auto">
                              {translations.map(t => (
                                <div key={t.id} className="bg-gray-50 rounded-lg p-4 border">
                                  <div className="flex justify-between items-start mb-3">
                                    <div>
                                      <span className="text-xs text-gray-500">{t.timestamp}</span>
                                      <div className="text-sm font-medium text-gray-700 mt-1">
                                        {t.sourceLang} ‚Üí {t.targetLang}
                                      </div>
                                    </div>
                                    <button
                                      onClick={() => setTranslations(translations.filter(tr => tr.id !== t.id))}
                                      className="text-red-500 hover:text-red-700"
                                    >
                                      üóëÔ∏è
                                    </button>
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <div className="bg-white p-3 rounded border">
                                      <div className="text-xs font-semibold text-gray-500 mb-1">ORIGINAL</div>
                                      <div className="text-gray-800">{t.original}</div>
                                    </div>
                                    
                                    {Object.entries(t.results).map(([id, result]) => (
                                      <div 
                                        key={id} 
                                        className={`p-3 rounded border ${
                                          result.error 
                                            ? 'bg-red-50 border-red-200' 
                                            : 'bg-blue-50 border-blue-200'
                                        }`}
                                      >
                                        <div className="flex justify-between items-start mb-1">
                                          <div className={`text-xs font-semibold ${
                                            result.error ? 'text-red-600' : 'text-blue-600'
                                          }`}>
                                            {result.name.toUpperCase()}
                                          </div>
                                          {!result.error && (
                                            <div className="flex gap-3 text-xs">
                                              {result.time !== undefined && (
                                                <span className="text-gray-600" title="Translation time">
                                                  ‚è±Ô∏è {(result.time / 1000).toFixed(2)}s
                                                </span>
                                              )}
                                              {result.cost !== undefined && result.cost > 0 && (
                                                <span className="text-green-700 font-semibold" title="Estimated cost">
                                                  üí∞ ${(result.cost / 100).toFixed(4)}
                                                </span>
                                              )}
                                            </div>
                                          )}
                                        </div>
                                        <div className={result.error ? 'text-red-700' : 'text-gray-800'}>
                                          {result.translation}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </>
                    )}

                    {/* BATCH TESTING MODE */}
                    {mode === 'test' && (
                      <>
                        <div className="bg-purple-50 p-4 rounded-lg border border-purple-200">
                          <h2 className="font-semibold mb-3 text-purple-900">üß™ Batch Testing Configuration</h2>
                          
                          {/* Translation Settings (System Prompt) */}
                          <div className="mb-4 p-3 bg-amber-50 rounded-lg border border-amber-200">
                            <h3 className="text-sm font-semibold text-amber-900 mb-2">‚öôÔ∏è Translation Settings</h3>
                            <div className="space-y-2">
                              <div>
                                <label className="block text-xs font-medium text-gray-700 mb-1">
                                  System Prompt
                                </label>
                                <input
                                  type="text"
                                  value={systemPrompt}
                                  onChange={(e) => setSystemPrompt(e.target.value)}
                                  placeholder="You are a professional translator..."
                                  className="w-full px-2 py-1.5 text-sm border rounded-lg"
                                />
                              </div>
                              <div>
                                <label className="block text-xs font-medium text-gray-700 mb-1">
                                  Style Instructions
                                </label>
                                <textarea
                                  value={styleInstructions}
                                  onChange={(e) => setStyleInstructions(e.target.value)}
                                  placeholder="Output ONLY the translated text..."
                                  className="w-full h-14 px-2 py-1.5 text-sm border rounded-lg resize-none"
                                />
                              </div>
                            </div>
                          </div>
                          
                          {/* Step 1: Select languages FIRST (important for TMX parsing) */}
                          <div className="grid grid-cols-2 gap-4 mb-4">
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">
                                1Ô∏è‚É£ Source Language
                              </label>
                              <select 
                                value={testSourceLang} 
                                onChange={(e) => setTestSourceLang(e.target.value)} 
                                className="w-full px-3 py-2 border rounded-lg"
                              >
                                {languages.map(l => (
                                  <option key={l.code} value={l.code}>{l.name}</option>
                                ))}
                              </select>
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-2">
                                1Ô∏è‚É£ Target Language
                              </label>
                              <select 
                                value={testTargetLang} 
                                onChange={(e) => setTestTargetLang(e.target.value)} 
                                className="w-full px-3 py-2 border rounded-lg"
                              >
                                {languages.map(l => (
                                  <option key={l.code} value={l.code}>{l.name}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                          
                          {/* Step 2: Select file format and upload */}
                          <div className="mb-3">
                            <p className="text-sm text-gray-600 mb-2">
                              2Ô∏è‚É£ Select file format and upload
                            </p>
                            <div className="flex gap-2 mb-2">
                              <button
                                onClick={() => setTestFileFormat('single')}
                                className={`px-3 py-1.5 text-sm rounded-lg border ${testFileFormat === 'single' ? 'bg-purple-600 text-white border-purple-600' : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'}`}
                              >
                                üìÑ TMX / JSON
                              </button>
                              <button
                                onClick={() => setTestFileFormat('opus-pair')}
                                className={`px-3 py-1.5 text-sm rounded-lg border ${testFileFormat === 'opus-pair' ? 'bg-purple-600 text-white border-purple-600' : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50'}`}
                              >
                                üìÑüìÑ OPUS Pair
                              </button>
                            </div>
                            
                            {testFileFormat === 'single' ? (
                              <>
                                <p className="text-xs text-purple-700 mb-2">
                                  üí° Upload TMX from <a href="https://opus.nlpl.eu" target="_blank" className="text-blue-600 underline">opus.nlpl.eu</a> or JSON file
                                </p>
                                <input
                                  type="file"
                                  accept=".json,.tmx"
                                  onChange={handleFileUpload}
                                  className="block w-full text-sm 
                                    file:mr-4 file:py-2 file:px-4 
                                    file:rounded-lg file:border-0 
                                    file:bg-purple-600 file:text-white 
                                    file:cursor-pointer hover:file:bg-purple-700"
                                />
                              </>
                            ) : (
                              <>
                                <p className="text-xs text-purple-700 mb-2">
                                  üí° Upload OPUS-100 parallel files: source (.en) and reference (.de/.ru/etc)
                                </p>
                                <div className="grid grid-cols-2 gap-2">
                                  <div>
                                    <label className="block text-xs text-gray-600 mb-1">Source file (.{testSourceLang})</label>
                                    <input
                                      id="opus-source"
                                      type="file"
                                      accept=".en,.de,.ru,.zh,.fr,.es,.it,.ja,.ko,.pt,.nl,.pl,.ar,.hi,.tr,.vi,.th,.cs,.el,.he,.hu,.id,.ro,.sv,.uk,*"
                                      className="block w-full text-xs 
                                        file:mr-2 file:py-1.5 file:px-3 
                                        file:rounded file:border-0 
                                        file:bg-blue-500 file:text-white 
                                        file:cursor-pointer hover:file:bg-blue-600"
                                    />
                                  </div>
                                  <div>
                                    <label className="block text-xs text-gray-600 mb-1">Reference file (.{testTargetLang})</label>
                                    <input
                                      id="opus-ref"
                                      type="file"
                                      accept=".en,.de,.ru,.zh,.fr,.es,.it,.ja,.ko,.pt,.nl,.pl,.ar,.hi,.tr,.vi,.th,.cs,.el,.he,.hu,.id,.ro,.sv,.uk,*"
                                      className="block w-full text-xs 
                                        file:mr-2 file:py-1.5 file:px-3 
                                        file:rounded file:border-0 
                                        file:bg-green-500 file:text-white 
                                        file:cursor-pointer hover:file:bg-green-600"
                                    />
                                  </div>
                                </div>
                                <button
                                  onClick={() => {
                                    const sourceInput = document.getElementById('opus-source');
                                    const refInput = document.getElementById('opus-ref');
                                    if (sourceInput.files[0] && refInput.files[0]) {
                                      handleOpusPairUpload(sourceInput.files[0], refInput.files[0]);
                                    } else {
                                      alert('Please select both source and reference files');
                                    }
                                  }}
                                  className="mt-2 w-full py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 text-sm font-medium"
                                >
                                  üì• Load OPUS Pair
                                </button>
                              </>
                            )}
                          </div>
                          
                          {/* Step 3: Test selection controls */}
                          {testDataFull.length > 0 && (
                            <div className="bg-white p-3 rounded border border-purple-300 mb-3">
                              <p className="text-sm font-semibold mb-2">
                                üìä {selectedTestFile} ‚Äî {testDataFull.length} total pairs
                              </p>
                              
                              <div className="grid grid-cols-3 gap-3 mb-3">
                                <div>
                                  <label className="block text-xs font-medium text-gray-600 mb-1">
                                    Selection Mode
                                  </label>
                                  <select 
                                    value={testSelection}
                                    onChange={(e) => setTestSelection(e.target.value)}
                                    className="w-full px-2 py-1.5 text-sm border rounded"
                                  >
                                    <option value="first">First N</option>
                                    <option value="random">Random N</option>
                                    <option value="range">From position</option>
                                  </select>
                                </div>
                                <div>
                                  <label className="block text-xs font-medium text-gray-600 mb-1">
                                    Number of Tests
                                  </label>
                                  <input 
                                    type="number"
                                    min="1"
                                    max={testDataFull.length}
                                    value={testLimit}
                                    onChange={(e) => setTestLimit(Math.max(1, Math.min(testDataFull.length, parseInt(e.target.value) || 1)))}
                                    className="w-full px-2 py-1.5 text-sm border rounded"
                                  />
                                </div>
                                {testSelection === 'range' && (
                                  <div>
                                    <label className="block text-xs font-medium text-gray-600 mb-1">
                                      Start From
                                    </label>
                                    <input 
                                      type="number"
                                      min="0"
                                      max={testDataFull.length - 1}
                                      value={testStartFrom}
                                      onChange={(e) => setTestStartFrom(Math.max(0, Math.min(testDataFull.length - 1, parseInt(e.target.value) || 0)))}
                                      className="w-full px-2 py-1.5 text-sm border rounded"
                                    />
                                  </div>
                                )}
                              </div>
                              
                              <div className="flex items-center gap-2">
                                <div className="flex-1 bg-purple-100 rounded-full h-2">
                                  <div 
                                    className="bg-purple-600 h-2 rounded-full transition-all"
                                    style={{ width: `${(testData.length / testDataFull.length) * 100}%` }}
                                  />
                                </div>
                                <span className="text-sm font-semibold text-purple-700">
                                  {testData.length} selected
                                </span>
                              </div>
                              
                              <p className="text-xs text-gray-500 mt-2">
                                {selectedTestFile.includes(' + ') ? 'üìÑüìÑ OPUS' : selectedTestFile.endsWith('.tmx') ? 'üìÑ TMX' : 'üìÑ JSON'} ‚Ä¢ 
                                {testData.filter(t => t.translation).length} with refs, 
                                {testData.filter(t => !t.translation).length} ref-free
                              </p>
                            </div>
                          )}
                        </div>

                        <div className="flex gap-3">
                          <button
                            onClick={runTests}
                            disabled={isLoadingTests || testData.length === 0 || selectedModels.length === 0}
                            className="flex-1 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            {isLoadingTests 
                              ? `‚è≥ Testing ${testResults.length}/${testData.length}...` 
                              : `üöÄ Run ${testData.length} Tests`
                            }
                          </button>
                          {isLoadingTests && (
                            <button
                              onClick={() => { shouldStopRef.current = true; }}
                              className="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                            >
                              ‚èπÔ∏è Stop
                            </button>
                          )}
                          <button
                            onClick={exportTestResults}
                            disabled={testResults.length === 0}
                            className="bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            üì• Export JSON
                          </button>
                        </div>

                        {testResults.length > 0 && (
                          <div>
                            <h3 className="text-lg font-semibold mb-3 text-gray-800">
                              üìä Test Results ({testResults.length})
                            </h3>
                            <div className="space-y-4 max-h-[600px] overflow-y-auto">
                              {testResults.map((r, i) => (
                                <div key={i} className="bg-gray-50 rounded-lg p-4 border">
                                  <div className="mb-3">
                                    <span className="text-xs font-semibold text-gray-500">
                                      TEST {i + 1} ({r.sourceLang} ‚Üí {r.targetLang})
                                    </span>
                                  </div>
                                  <div className="space-y-2">
                                    <div className="bg-white p-3 rounded border">
                                      <div className="text-xs font-semibold text-gray-500 mb-1">ORIGINAL</div>
                                      <div className="text-sm">{r.original}</div>
                                    </div>
                                    <div className="bg-green-50 p-3 rounded border border-green-200">
                                      <div className="text-xs font-semibold text-green-600 mb-1">REFERENCE</div>
                                      <div className="text-sm">{r.reference}</div>
                                    </div>
                                    {Object.entries(r.modelResults).map(([id, result]) => (
                                      <div 
                                        key={id} 
                                        className={`p-3 rounded border ${
                                          result.error 
                                            ? 'bg-red-50 border-red-200' 
                                            : 'bg-blue-50 border-blue-200'
                                        }`}
                                      >
                                        <div className="flex justify-between items-start mb-1">
                                          <div className={`text-xs font-semibold ${
                                            result.error ? 'text-red-600' : 'text-blue-600'
                                          }`}>
                                            {result.name.toUpperCase()}
                                          </div>
                                          {!result.error && (
                                            <div className="flex gap-3 text-xs">
                                              {result.time !== undefined && (
                                                <span className="text-gray-600" title="Translation time">
                                                  ‚è±Ô∏è {(result.time / 1000).toFixed(2)}s
                                                </span>
                                              )}
                                              {result.cost !== undefined && result.cost > 0 && (
                                                <span className="text-green-700 font-semibold" title="Estimated cost">
                                                  üí∞ ${(result.cost / 100).toFixed(4)}
                                                </span>
                                              )}
                                            </div>
                                          )}
                                        </div>
                                        <div className={`text-sm ${
                                          result.error ? 'text-red-700' : 'text-gray-800'
                                        }`}>
                                          {result.translation}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}
                      </>
                    )}

                    {/* EVALUATION WITH REFERENCE MODE */}
                    {mode === 'eval-ref' && (
                      <>
                        <div className="bg-green-50 p-4 rounded-lg border border-green-200">
                          <h2 className="font-semibold mb-3 text-green-900">
                            ‚úÖ Evaluation with Reference Translation
                          </h2>
                          <p className="text-sm text-gray-600 mb-3">
                            Upload a JSON file with test results (exported from Batch Testing).
                          </p>
                          <p className="text-sm text-gray-600 mb-3">
                            <strong>Metrics calculated:</strong> BLEU, METEOR, CER, WER, Jaccard, chrF, Length Ratio, Total Score
                          </p>
                          
                          {/* Evaluation Methods Selection with Weights */}
                          <div className="bg-white p-3 rounded-lg border border-green-300 mb-3">
                            <h3 className="text-sm font-semibold text-gray-700 mb-2">üìä Select Metrics & Set Weights for Total Score:</h3>
                            <div className="grid grid-cols-3 gap-2">
                              {/* BLEU */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.bleu}>
                                <input type="checkbox" checked={evalMethods.bleu} onChange={(e) => setEvalMethods({...evalMethods, bleu: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">BLEU</span>
                                <input type="number" min="0" max="100" value={metricWeights.bleu} onChange={(e) => setMetricWeights({...metricWeights, bleu: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* METEOR */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.meteor}>
                                <input type="checkbox" checked={evalMethods.meteor} onChange={(e) => setEvalMethods({...evalMethods, meteor: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">METEOR</span>
                                <input type="number" min="0" max="100" value={metricWeights.meteor} onChange={(e) => setMetricWeights({...metricWeights, meteor: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* CER */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.cer}>
                                <input type="checkbox" checked={evalMethods.cer} onChange={(e) => setEvalMethods({...evalMethods, cer: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">CER ‚Üì</span>
                                <input type="number" min="0" max="100" value={metricWeights.cer} onChange={(e) => setMetricWeights({...metricWeights, cer: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* WER */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.wer}>
                                <input type="checkbox" checked={evalMethods.wer} onChange={(e) => setEvalMethods({...evalMethods, wer: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">WER ‚Üì</span>
                                <input type="number" min="0" max="100" value={metricWeights.wer} onChange={(e) => setMetricWeights({...metricWeights, wer: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* Jaccard */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.jaccard}>
                                <input type="checkbox" checked={evalMethods.jaccard} onChange={(e) => setEvalMethods({...evalMethods, jaccard: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">Jaccard</span>
                                <input type="number" min="0" max="100" value={metricWeights.jaccard} onChange={(e) => setMetricWeights({...metricWeights, jaccard: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* chrF */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.chrf}>
                                <input type="checkbox" checked={evalMethods.chrf} onChange={(e) => setEvalMethods({...evalMethods, chrf: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">chrF</span>
                                <input type="number" min="0" max="100" value={metricWeights.chrf} onChange={(e) => setMetricWeights({...metricWeights, chrf: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* Length Ratio */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50" title={metricDescriptions.lengthRatio}>
                                <input type="checkbox" checked={evalMethods.lengthRatio} onChange={(e) => setEvalMethods({...evalMethods, lengthRatio: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">Length</span>
                                <input type="number" min="0" max="100" value={metricWeights.lengthRatio} onChange={(e) => setMetricWeights({...metricWeights, lengthRatio: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* BERTScore */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50 bg-blue-50" title={metricDescriptions.bertScore}>
                                <input type="checkbox" checked={evalMethods.bertScore} onChange={(e) => setEvalMethods({...evalMethods, bertScore: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">üî∑ BERT</span>
                                <input type="number" min="0" max="100" value={metricWeights.bertScore} onChange={(e) => setMetricWeights({...metricWeights, bertScore: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* COMET */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50 bg-blue-50" title={metricDescriptions.comet}>
                                <input type="checkbox" checked={evalMethods.comet} onChange={(e) => setEvalMethods({...evalMethods, comet: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">üî∑ COMET</span>
                                <input type="number" min="0" max="100" value={metricWeights.comet} onChange={(e) => setMetricWeights({...metricWeights, comet: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                              {/* BLEURT */}
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-green-50 bg-blue-50" title={metricDescriptions.bleurt}>
                                <input type="checkbox" checked={evalMethods.bleurt} onChange={(e) => setEvalMethods({...evalMethods, bleurt: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">üî∑ BLEURT</span>
                                <input type="number" min="0" max="100" value={metricWeights.bleurt} onChange={(e) => setMetricWeights({...metricWeights, bleurt: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                            </div>
                            <p className="text-xs text-gray-500 mt-2">
                              ‚öñÔ∏è Total Weight: {Object.values(metricWeights).reduce((a, b) => a + b, 0)} 
                              <span className="text-gray-400 ml-2">(weights are relative, don't need to sum to 100)</span>
                            </p>
                          </div>
                          
                          <input
                            type="file"
                            accept=".json"
                            onChange={handleEvalFileUpload}
                            className="block w-full text-sm mb-3 
                              file:mr-4 file:py-2 file:px-4 
                              file:rounded-lg file:border-0 
                              file:bg-green-600 file:text-white 
                              file:cursor-pointer hover:file:bg-green-700"
                          />
                          
                          {selectedEvalFile && (
                            <div className="bg-white p-3 rounded border border-green-300">
                              <p className="text-sm font-semibold">
                                üìä {selectedEvalFile} ({evalData.length} rows)
                              </p>
                            </div>
                          )}
                          
                          {evalWarning && (
                            <div className="bg-red-50 p-3 rounded-lg border-2 border-red-300 mt-3">
                              <p className="text-sm font-semibold text-red-800">
                                {evalWarning}
                              </p>
                            </div>
                          )}
                        </div>

                        <div className="flex gap-3">
                          <button
                            onClick={runReferenceEvaluation}
                            disabled={isEvaluating || evalData.length === 0}
                            className="flex-1 bg-green-600 hover:bg-green-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            {isEvaluating 
                              ? `‚è≥ Evaluating ${evalResults.length}/${evalData.length}...` 
                              : `üìä Calculate Metrics (${evalData.length} items)`
                            }
                          </button>
                          {isEvaluating && (
                            <button
                              onClick={() => { shouldStopRef.current = true; }}
                              className="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                            >
                              ‚èπÔ∏è Stop
                            </button>
                          )}
                          <button
                            onClick={exportEvalResults}
                            disabled={evalResults.length === 0}
                            className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            üì• Export JSON
                          </button>
                        </div>

                        {evalResults.length > 0 && (
                          <div>
                            <h3 className="text-lg font-semibold mb-3 text-gray-800">
                              üìä Evaluation Results ({evalResults.length})
                            </h3>
                            <div className="space-y-4 max-h-[600px] overflow-y-auto">
                              {evalResults.map((r, i) => (
                                <div key={i} className="bg-gray-50 rounded-lg p-4 border">
                                  <div className="mb-2">
                                    <span className="text-xs font-semibold text-gray-500">ORIGINAL:</span>
                                    <div className="text-sm">{r.original}</div>
                                  </div>
                                  <div className="mb-3">
                                    <span className="text-xs font-semibold text-green-600">REFERENCE:</span>
                                    <div className="text-sm text-green-700 font-medium">{r.reference}</div>
                                  </div>
                                  <div className="space-y-2">
                                    {Object.entries(r.evaluations).map(([model, metrics]) => (
                                      <div key={model} className="bg-white p-3 rounded border">
                                        <div className="text-xs font-semibold text-blue-600 mb-1">
                                          {model}
                                        </div>
                                        <div className="text-sm mb-2 text-gray-800">{metrics.translation}</div>
                                        <div className="grid grid-cols-4 md:grid-cols-8 gap-2 text-xs">
                                          {metrics.total !== undefined && metrics.total !== 'N/A' && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('total', metrics.total)} border-2 border-purple-400`} title={metricDescriptions.total}>
                                              <div className="font-semibold">‚≠ê TOTAL</div>
                                              <div className="font-bold text-lg">{metrics.total}</div>
                                            </div>
                                          )}
                                          {metrics.bleu !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('bleu', metrics.bleu)}`} title={metricDescriptions.bleu}>
                                              <div className="font-semibold">BLEU ‚Üë</div>
                                              <div className="font-bold">{metrics.bleu}</div>
                                            </div>
                                          )}
                                          {metrics.meteor !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('meteor', metrics.meteor)}`} title={metricDescriptions.meteor}>
                                              <div className="font-semibold">METEOR ‚Üë</div>
                                              <div className="font-bold">{metrics.meteor}</div>
                                            </div>
                                          )}
                                          {metrics.cer !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('cer', metrics.cer)}`} title={metricDescriptions.cer}>
                                              <div className="font-semibold">CER ‚Üì</div>
                                              <div className="font-bold">{metrics.cer}%</div>
                                            </div>
                                          )}
                                          {metrics.wer !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('wer', metrics.wer)}`} title={metricDescriptions.wer}>
                                              <div className="font-semibold">WER ‚Üì</div>
                                              <div className="font-bold">{metrics.wer}%</div>
                                            </div>
                                          )}
                                          {metrics.jaccard !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('jaccard', metrics.jaccard)}`} title={metricDescriptions.jaccard}>
                                              <div className="font-semibold">Jaccard ‚Üë</div>
                                              <div className="font-bold">{metrics.jaccard}%</div>
                                            </div>
                                          )}
                                          {metrics.chrF !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('chrF', metrics.chrF)}`} title={metricDescriptions.chrf}>
                                              <div className="font-semibold">chrF ‚Üë</div>
                                              <div className="font-bold">{metrics.chrF}</div>
                                            </div>
                                          )}
                                          {metrics.lengthRatio !== undefined && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('lengthRatio', metrics.lengthRatio)}`} title={metricDescriptions.lengthRatio}>
                                              <div className="font-semibold">Len% ‚âà100</div>
                                              <div className="font-bold">{metrics.lengthRatio}%</div>
                                            </div>
                                          )}
                                          {metrics.bertScore !== undefined && metrics.bertScore !== 'N/A' && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('bertScore', metrics.bertScore)}`} title={metricDescriptions.bertScore}>
                                              <div className="font-semibold">üî∑ BERT ‚Üë</div>
                                              <div className="font-bold">{metrics.bertScore}</div>
                                            </div>
                                          )}
                                          {metrics.comet !== undefined && metrics.comet !== 'N/A' && (
                                            <div className={`p-2 rounded text-center ${getMetricColorClass('comet', metrics.comet)}`} title={metricDescriptions.comet}>
                                              <div className="font-semibold">üî∑ COMET ‚Üë</div>
                                              <div className="font-bold">{metrics.comet}</div>
                                            </div>
                                          )}
                                        </div>
                                      </div>
                                    ))}
                                  </div>
                                </div>
                              ))}
                            </div>
                            
                            {/* Statistics Summary */}
                            {(() => {
                              const stats = calculateStatistics();
                              if (!stats) return null;
                              
                              const models = Object.keys(stats);
                              const metrics = ['total', 'bleu', 'meteor', 'cer', 'wer', 'jaccard', 'chrF', 'lengthRatio', 'bertScore', 'comet', 'bleurt'];
                              const availableMetrics = metrics.filter(m => 
                                models.some(model => stats[model][m] !== undefined)
                              );
                              
                              // Calculate chart data for bar chart
                              const chartMetrics = ['total', 'bleu', 'meteor', 'bertScore', 'comet', 'bleurt'].filter(m => 
                                models.some(model => stats[model][m] !== undefined)
                              );
                              const maxValue = Math.max(...chartMetrics.flatMap(m => 
                                models.map(model => parseFloat(stats[model][m]) || 0)
                              ));
                              
                              // Colors for different models
                              const modelColors = [
                                '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', 
                                '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
                              ];
                              
                              return (
                                <div className="mt-6 border-t-2 pt-6">
                                  <h3 className="text-xl font-bold mb-4 text-gray-800">
                                    üìà Overall Statistics (Averages Across All Texts)
                                  </h3>
                                  
                                  
                                  {/* Summary Table */}
                                  <div className="bg-white rounded-lg border-2 overflow-hidden mb-6">
                                    <table className="w-full text-sm">
                                      <thead className="bg-gray-100">
                                        <tr>
                                          <th className="px-4 py-3 text-left font-bold text-gray-700">Model</th>
                                          {availableMetrics.map(metric => (
                                            <th key={metric} className="px-4 py-3 text-center font-bold text-gray-700" title={metricDescriptions[metric]}>
                                              {metricsInfo[metric]?.name || metric}
                                              <div className="text-xs font-normal text-gray-500">
                                                {metricsInfo[metric]?.description || ''}
                                              </div>
                                            </th>
                                          ))}
                                        </tr>
                                      </thead>
                                      <tbody>
                                        {models.map((model, idx) => {
                                          const isReference = model.includes('Reference');
                                          return (
                                            <tr key={model} className={isReference ? 'bg-purple-50' : (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50')}>
                                              <td className={`px-4 py-3 font-semibold ${isReference ? 'text-purple-700' : 'text-blue-700'}`}>{model}</td>
                                              {availableMetrics.map(metric => {
                                                const value = stats[model][metric];
                                                const std = stats[model][metric + '_std'];
                                                const min = stats[model][metric + '_min'];
                                                const max = stats[model][metric + '_max'];
                                                const suffix = (metric === 'cer' || metric === 'wer' || metric === 'jaccard' || metric === 'lengthRatio') ? '%' : '';
                                                return (
                                                  <td key={metric} className="px-4 py-3 text-center">
                                                    {value !== undefined ? (
                                                      <div className="flex flex-col items-center">
                                                        <span className={`inline-block px-3 py-1 rounded font-bold ${getMetricColorClass(metric, value)}`} title={metricDescriptions[metric]}>
                                                          {value}{suffix}
                                                        </span>
                                                        {std && parseFloat(std) > 0 && (
                                                          <span className="text-xs text-gray-500 mt-0.5" title={`Min: ${min}${suffix}, Max: ${max}${suffix}`}>
                                                            ¬±{std}
                                                          </span>
                                                        )}
                                                      </div>
                                                    ) : (
                                                      <span className="text-gray-400">‚Äî</span>
                                                    )}
                                                  </td>
                                                );
                                              })}
                                            </tr>
                                          );
                                        })}
                                      </tbody>
                                    </table>
                                  </div>
                                  
                                  {/* Time & Cost Summary */}
                                  {(() => {
                                    const hasTimeCost = models.some(m => 
                                      stats[m].time !== undefined || stats[m].cost_total !== undefined
                                    );
                                    if (!hasTimeCost) return null;
                                    
                                    return (
                                      <div className="bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg border-2 border-purple-200 mb-6">
                                        <h4 className="font-bold text-purple-900 mb-3">‚è±Ô∏è Time & üí∞ Cost Summary</h4>
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                          {models.map(model => {
                                            const time = stats[model].time_total;
                                            const cost = stats[model].cost_total;
                                            if (!time && !cost) return null;
                                            
                                            return (
                                              <div key={model} className="bg-white p-3 rounded-lg border">
                                                <div className="font-semibold text-sm text-gray-800 mb-2 truncate" title={model}>
                                                  {model.length > 30 ? model.substring(0, 28) + '...' : model}
                                                </div>
                                                <div className="space-y-1 text-xs">
                                                  {time && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-600">Total Time:</span>
                                                      <span className="font-bold text-blue-700">{time}s</span>
                                                    </div>
                                                  )}
                                                  {cost && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-600">Total Cost:</span>
                                                      <span className="font-bold text-green-700">${cost}</span>
                                                    </div>
                                                  )}
                                                  {stats[model].time && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-500">Avg Time:</span>
                                                      <span className="text-gray-700">{stats[model].time}s</span>
                                                    </div>
                                                  )}
                                                  {stats[model].cost && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-500">Avg Cost:</span>
                                                      <span className="text-gray-700">${stats[model].cost}</span>
                                                    </div>
                                                  )}
                                                </div>
                                              </div>
                                            );
                                          })}
                                        </div>
                                      </div>
                                    );
                                  })()}
                                  
                                  
                                  {/* Advanced Analytics */}
                                  <div className="mt-8 border-t-4 border-indigo-400 pt-6">
                                    <h3 className="text-2xl font-bold mb-6 text-indigo-900 flex items-center gap-2">
                                      üìä Advanced Analytics
                                    </h3>
                                    
                                    {(() => {
                                      // Prepare data for all charts
                                      const chartData = models
                                        .filter(m => stats[m].total !== undefined)
                                        .map(model => {
                                          const meta = getModelMeta(model);
                                          // Use actual cost if available, otherwise estimate from metadata
                                          // priceOut is per 1M tokens, estimate ~100 tokens per text
                                          const actualCost = parseFloat(stats[model].cost_total) || 0;
                                          const estimatedCost = meta.priceOut > 0 ? meta.priceOut / 10000 : 0;
                                          const releaseDate = meta.released ? new Date(meta.released) : null;
                                          return {
                                            model,
                                            shortName: model.length > 15 ? model.substring(0, 13) + '...' : model,
                                            quality: parseFloat(stats[model].total) || 0,
                                            cost: actualCost > 0 ? actualCost : estimatedCost,
                                            costIsEstimate: actualCost === 0,
                                            pricePerMToken: meta.priceOut,
                                            time: parseFloat(stats[model].time) || 0,
                                            released: releaseDate,
                                            releasedYear: releaseDate ? releaseDate.getFullYear() + (releaseDate.getMonth() / 12) : null,
                                            company: meta.company,
                                            type: meta.type,
                                            sizeB: meta.sizeB,
                                            perPair: meta.perPair || false,
                                            isReference: model.includes('Reference')
                                          };
                                        });
                                      
                                      console.log('üìä Chart data:', chartData.map(d => ({model: d.model, quality: d.quality, cost: d.cost, pricePerMToken: d.pricePerMToken, time: d.time, sizeB: d.sizeB})));
                                      
                                      return (
                                        <>
                                          {/* Chart 1: Model Ranking (simple table, no bars) */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-indigo-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-4">üèÜ Model Ranking</h4>
                                            <table className="w-full text-sm">
                                              <thead>
                                                <tr className="border-b-2 border-gray-200">
                                                  <th className="text-left py-2 w-12">#</th>
                                                  <th className="text-left py-2">Model</th>
                                                  <th className="text-left py-2">Company</th>
                                                  <th className="text-right py-2">Quality</th>
                                                </tr>
                                              </thead>
                                              <tbody>
                                                {[...chartData]
                                                  .sort((a, b) => b.quality - a.quality)
                                                  .map((d, idx) => {
                                                    const medal = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : `${idx + 1}`;
                                                    return (
                                                      <tr key={d.model} className={`border-b ${d.isReference ? 'bg-purple-50' : ''}`}>
                                                        <td className="py-2 font-bold text-center">{medal}</td>
                                                        <td className={`py-2 ${d.isReference ? 'text-purple-700 font-bold' : ''}`}>{d.model}</td>
                                                        <td className="py-2 text-gray-600">{d.company}</td>
                                                        <td className="py-2 text-right font-bold" style={{ color: d.isReference ? '#9333EA' : companyColors[d.company] }}>
                                                          {d.quality.toFixed(1)}
                                                        </td>
                                                      </tr>
                                                    );
                                                  })}
                                              </tbody>
                                            </table>
                                          </div>
                                          
                                          {/* Chart 2: Quality vs Price (XY) */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-green-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üí∞ Quality vs Price</h4>
                                            <p className="text-sm text-gray-500 mb-4">Higher and more left = better value (price per 1M output tokens)</p>
                                            <ScatterPlot 
                                              data={chartData.filter(d => !d.isReference)}
                                              xKey="pricePerMToken"
                                              xLabel="Price per 1M tokens ($)"
                                              yLabel="Quality Score"
                                              title="Quality vs Price"
                                              xFormat={(v) => v === 0 ? 'FREE' : '$' + v.toFixed(2)}
                                            />
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k)).map(([company, color]) => (
                                                <span key={company} className="flex items-center gap-1 text-xs">
                                                  <span className="w-3 h-3 rounded-full" style={{ backgroundColor: color }}></span>
                                                  {company}
                                                </span>
                                              ))}
                                            </div>
                                          </div>
                                          
                                          {/* Chart 3: Quality vs Speed (XY) */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-blue-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">‚ö° Quality vs Speed</h4>
                                            <p className="text-sm text-gray-500 mb-4">Higher and more left = better (fast & good)</p>
                                            <ScatterPlot 
                                              data={chartData.filter(d => !d.isReference)}
                                              xKey="time"
                                              xLabel="Avg Time (seconds)"
                                              yLabel="Quality Score"
                                              title="Quality vs Time"
                                              xFormat={(v) => v.toFixed(1) + 's'}
                                            />
                                          </div>
                                          
                                          {/* Chart 4: Quality vs Release Date (XY) - Evolution */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-purple-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üìÖ Quality vs Release Date</h4>
                                            <p className="text-sm text-gray-500 mb-4">Are newer models better? (Right = newer)</p>
                                            <ScatterPlot 
                                              data={chartData.filter(d => d.releasedYear !== null)}
                                              xKey="releasedYear"
                                              xLabel="Release Date"
                                              yLabel="Quality Score"
                                              title="Model Evolution Over Time"
                                              xFormat={(v) => Math.floor(v).toString()}
                                            />
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k)).map(([company, color]) => (
                                                <span key={company} className="flex items-center gap-1 text-xs">
                                                  <span className="w-3 h-3 rounded-full" style={{ backgroundColor: color }}></span>
                                                  {company}
                                                </span>
                                              ))}
                                            </div>
                                          </div>
                                          
                                          {/* Chart 5: Quality vs Model Size (XY) */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-orange-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üìê Quality vs Model Size</h4>
                                            <p className="text-sm text-gray-500 mb-4">Does size matter? (X = model parameters in billions, log scale. Argos/OPUS-MT sizes are per language pair)</p>
                                            <ScatterPlot 
                                              data={chartData.filter(d => d.sizeB && d.sizeB > 0)}
                                              xKey="sizeB"
                                              xLabel="Model Size (Billion params)"
                                              yLabel="Quality Score"
                                              title="Quality vs Model Size"
                                              xFormat={(v) => v >= 1000 ? (v/1000).toFixed(1) + 'T' : v >= 1 ? v.toFixed(0) + 'B' : (v*1000).toFixed(0) + 'M'}
                                              logScale={true}
                                            />
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k && d.sizeB > 0)).map(([company, color]) => (
                                                <span key={company} className="flex items-center gap-1 text-xs">
                                                  <span className="w-3 h-3 rounded-full" style={{ backgroundColor: color }}></span>
                                                  {company}
                                                </span>
                                              ))}
                                            </div>
                                          </div>
                                          
                                          {/* Summary Insights */}
                                          <div className="bg-gradient-to-r from-indigo-50 to-purple-50 p-6 rounded-xl border-2 border-indigo-300">
                                            <h4 className="text-lg font-bold text-indigo-900 mb-4">üìã Quick Insights</h4>
                                            {(() => {
                                              const nonRef = chartData.filter(d => !d.isReference);
                                              if (nonRef.length === 0) return <p className="text-gray-500">No data</p>;
                                              
                                              const best = nonRef.reduce((a, b) => a.quality > b.quality ? a : b);
                                              const fastest = nonRef.filter(d => d.time > 0).length > 0 ? 
                                                nonRef.filter(d => d.time > 0).reduce((a, b) => a.time < b.time ? a : b) : null;
                                              const paidModels = nonRef.filter(d => d.pricePerMToken > 0);
                                              const cheapestPaid = paidModels.length > 0 ? 
                                                paidModels.reduce((a, b) => a.pricePerMToken < b.pricePerMToken ? a : b) : null;
                                              const bestValue = nonRef.reduce((a, b) => {
                                                const aEff = a.pricePerMToken > 0 ? a.quality / a.pricePerMToken : 9999;
                                                const bEff = b.pricePerMToken > 0 ? b.quality / b.pricePerMToken : 9999;
                                                return aEff > bEff ? a : b;
                                              });
                                              
                                              return (
                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                                  <div className="bg-white p-3 rounded-lg flex items-center gap-2">
                                                    <span className="text-2xl">üèÜ</span>
                                                    <div>
                                                      <div className="text-gray-600">Best Quality</div>
                                                      <div className="font-bold" style={{ color: companyColors[best.company] }}>{best.model}</div>
                                                      <div className="text-xs text-gray-500">Score: {best.quality.toFixed(1)}</div>
                                                    </div>
                                                  </div>
                                                  <div className="bg-white p-3 rounded-lg flex items-center gap-2">
                                                    <span className="text-2xl">üíé</span>
                                                    <div>
                                                      <div className="text-gray-600">Best Value</div>
                                                      <div className="font-bold" style={{ color: companyColors[bestValue.company] }}>{bestValue.model}</div>
                                                      <div className="text-xs text-gray-500">
                                                        Q:{bestValue.quality.toFixed(0)} / {bestValue.pricePerMToken > 0 ? '$'+bestValue.pricePerMToken+'/1M' : 'FREE'}
                                                      </div>
                                                    </div>
                                                  </div>
                                                  {fastest && (
                                                    <div className="bg-white p-3 rounded-lg flex items-center gap-2">
                                                      <span className="text-2xl">‚ö°</span>
                                                      <div>
                                                        <div className="text-gray-600">Fastest</div>
                                                        <div className="font-bold" style={{ color: companyColors[fastest.company] }}>{fastest.model}</div>
                                                        <div className="text-xs text-gray-500">{fastest.time.toFixed(1)}s total</div>
                                                      </div>
                                                    </div>
                                                  )}
                                                  {cheapestPaid && (
                                                    <div className="bg-white p-3 rounded-lg flex items-center gap-2">
                                                      <span className="text-2xl">üí∞</span>
                                                      <div>
                                                        <div className="text-gray-600">Cheapest (paid)</div>
                                                        <div className="font-bold" style={{ color: companyColors[cheapestPaid.company] }}>{cheapestPaid.model}</div>
                                                        <div className="text-xs text-gray-500">${cheapestPaid.pricePerMToken}/1M tokens</div>
                                                      </div>
                                                    </div>
                                                  )}
                                                </div>
                                              );
                                            })()}
                                          </div>
                                        </>
                                      );
                                    })()}
                                  </div>
                                </div>
                              );
                            })()}
                          </div>
                        )}
                      </>
                    )}

                    {/* EVALUATION WITHOUT REFERENCE (LLM JUDGE) MODE */}
                    {mode === 'eval-noref' && (
                      <>
                        <div className="bg-orange-50 p-4 rounded-lg border border-orange-200">
                          <h2 className="font-semibold mb-3 text-orange-900">
                            ü§ñ Evaluation WITHOUT Reference
                          </h2>
                          <p className="text-sm text-gray-600 mb-3">
                            Upload a JSON file with translations. An LLM will evaluate each translation for fluency, adequacy, and overall quality.
                          </p>
                          <p className="text-sm text-orange-700 mb-3">
                            üí° If file contains reference translations, they will be included as "Reference" in the comparison.
                          </p>
                          <p className="text-sm text-gray-600 mb-3">
                            <strong>Metrics:</strong> LLM Quality Score (0-10), Fluency, Adequacy, plus basic metrics (Length Ratio, Jaccard, etc.)
                          </p>
                          
                          {/* Evaluation Methods Selection */}
                          <div className="bg-white p-3 rounded-lg border border-orange-300 mb-3">
                            <h3 className="text-sm font-semibold text-gray-700 mb-2">üìä Select Metrics & Set Weights for Total Score:</h3>
                            
                            {/* LLM and Basic toggles */}
                            <div className="space-y-2 mb-3">
                              <label className="flex items-center gap-2 text-sm cursor-pointer hover:bg-orange-50 p-2 rounded" title={metricDescriptions.score}>
                                <input type="checkbox" checked={evalMethods.llmJudge} onChange={(e) => setEvalMethods({...evalMethods, llmJudge: e.target.checked})} className="w-4 h-4" />
                                <span className="font-medium flex-1">ü§ñ LLM Evaluation (Overall, Fluency, Adequacy)</span>
                                <input type="number" min="0" max="100" value={noRefWeights.llmScore} onChange={(e) => setNoRefWeights({...noRefWeights, llmScore: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" title="Weight for LLM Score" />
                              </label>
                              <label className="flex items-center gap-2 text-sm cursor-pointer hover:bg-orange-50 p-2 rounded">
                                <input type="checkbox" checked={evalMethods.basicMetrics} onChange={(e) => setEvalMethods({...evalMethods, basicMetrics: e.target.checked})} className="w-4 h-4" />
                                <span className="font-medium flex-1">üìä Basic Metrics (Length Ratio, Jaccard, Word/Char Count)</span>
                                <input type="number" min="0" max="100" value={noRefWeights.lengthRatio} onChange={(e) => setNoRefWeights({...noRefWeights, lengthRatio: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" title="Weight for Length" />
                              </label>
                            </div>
                            
                            {/* Quality Metrics with weights */}
                            <div className="border-t pt-2">
                              <p className="text-xs text-gray-500 mb-2">üîß Quality Metrics (No LLM Required):</p>
                              <div className="grid grid-cols-2 gap-2">
                                <div className="flex items-center gap-1 p-2 rounded hover:bg-orange-50" title={metricDescriptions.repetition}>
                                  <input type="checkbox" checked={evalMethods.repetition} onChange={(e) => setEvalMethods({...evalMethods, repetition: e.target.checked})} className="w-4 h-4" />
                                  <span className="text-sm flex-1">üîÅ Repetition ‚Üì</span>
                                  <input type="number" min="0" max="100" value={noRefWeights.repetition} onChange={(e) => setNoRefWeights({...noRefWeights, repetition: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                                </div>
                                <div className="flex items-center gap-1 p-2 rounded hover:bg-orange-50" title={metricDescriptions.numberPres}>
                                  <input type="checkbox" checked={evalMethods.numberPres} onChange={(e) => setEvalMethods({...evalMethods, numberPres: e.target.checked})} className="w-4 h-4" />
                                  <span className="text-sm flex-1">üî¢ Numbers ‚Üë</span>
                                  <input type="number" min="0" max="100" value={noRefWeights.numberPres} onChange={(e) => setNoRefWeights({...noRefWeights, numberPres: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                                </div>
                                <div className="flex items-center gap-1 p-2 rounded hover:bg-orange-50" title={metricDescriptions.copyRate}>
                                  <input type="checkbox" checked={evalMethods.copyRate} onChange={(e) => setEvalMethods({...evalMethods, copyRate: e.target.checked})} className="w-4 h-4" />
                                  <span className="text-sm flex-1">üìã Copy Rate</span>
                                  <input type="number" min="0" max="100" value={noRefWeights.copyRate} onChange={(e) => setNoRefWeights({...noRefWeights, copyRate: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                                </div>
                                <div className="flex items-center gap-1 p-2 rounded hover:bg-orange-50" title={metricDescriptions.sentenceCount}>
                                  <input type="checkbox" checked={evalMethods.sentenceCount} onChange={(e) => setEvalMethods({...evalMethods, sentenceCount: e.target.checked})} className="w-4 h-4" />
                                  <span className="text-sm flex-1">üìù Sentence Align</span>
                                  <span className="text-xs text-gray-400 w-12 text-center">-</span>
                                </div>
                              </div>
                            </div>
                            
                            {/* Neural Metrics */}
                            <div className="border-t pt-2 mt-2">
                              <p className="text-xs text-gray-500 mb-2">üß† Neural Metrics:</p>
                              <div className="flex items-center gap-1 p-2 rounded hover:bg-orange-50 bg-blue-50" title={metricDescriptions.cometQE}>
                                <input type="checkbox" checked={evalMethods.cometQE} onChange={(e) => setEvalMethods({...evalMethods, cometQE: e.target.checked})} className="w-4 h-4" />
                                <span className="text-sm flex-1">üî∑ COMET-QE (No reference needed)</span>
                                <input type="number" min="0" max="100" value={noRefWeights.cometQE} onChange={(e) => setNoRefWeights({...noRefWeights, cometQE: parseInt(e.target.value) || 0})} className="w-12 px-1 py-0.5 text-xs border rounded text-center" />
                              </div>
                            </div>
                            
                            <p className="text-xs text-gray-500 mt-2">
                              ‚öñÔ∏è Total Weight: {Object.values(noRefWeights).reduce((a, b) => a + b, 0)} 
                              <span className="text-gray-400 ml-2">(weights are relative)</span>
                            </p>
                          </div>
                          
                          {evalMethods.llmJudge && (
                          <>
                          <div className="mb-3">
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                              Evaluator Model
                            </label>
                            <select 
                              value={evaluatorModel} 
                              onChange={(e) => setEvaluatorModel(e.target.value)} 
                              className="w-full px-3 py-2 border rounded-lg"
                            >
                              <option value="deepseek-chat">DeepSeek Chat (Recommended - Fastest & Cheapest)</option>
                              <option value="claude-sonnet-4.5">Claude Sonnet 4.5 (High Quality)</option>
                              <option value="claude-haiku-4.5">Claude Haiku 4.5 (Fast & Cheap)</option>
                              <option value="gpt-4o">GPT-4o (Fast)</option>
                            </select>
                          </div>
                          
                          <div className="mb-3">
                            <label className="block text-sm font-medium text-gray-700 mb-2">
                              Evaluator API Key (Optional)
                            </label>
                            <input
                              type="password"
                              placeholder="sk-ant-... or sk-... (Leave empty to skip LLM evaluation)"
                              value={evaluatorApiKey}
                              onChange={(e) => setEvaluatorApiKey(e.target.value)}
                              className="w-full px-3 py-2 border rounded-lg text-sm font-mono"
                            />
                            <p className="text-xs text-gray-500 mt-1">
                              üí° Without API key, only basic metrics (Length Ratio, Jaccard, Word/Char count) will be calculated
                            </p>
                          </div>
                          </>
                          )}
                          
                          <input
                            type="file"
                            accept=".json"
                            onChange={handleEvalFileUpload}
                            className="block w-full text-sm mb-3 
                              file:mr-4 file:py-2 file:px-4 
                              file:rounded-lg file:border-0 
                              file:bg-orange-600 file:text-white 
                              file:cursor-pointer hover:file:bg-orange-700"
                          />
                          
                          {selectedEvalFile && (
                            <div className="bg-white p-3 rounded border border-orange-300">
                              <p className="text-sm font-semibold">
                                üìä {selectedEvalFile} ({evalData.length} rows)
                              </p>
                            </div>
                          )}
                          
                          {evalWarning && (
                            <div className="bg-red-50 p-3 rounded-lg border-2 border-red-300 mt-3">
                              <p className="text-sm font-semibold text-red-800">
                                {evalWarning}
                              </p>
                            </div>
                          )}
                        </div>

                        <div className="flex gap-3">
                          <button
                            onClick={runNoReferenceEvaluation}
                            disabled={isEvaluating || evalData.length === 0}
                            className="flex-1 bg-orange-600 hover:bg-orange-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            {isEvaluating 
                              ? `‚è≥ Evaluating ${evalResults.length}/${evalData.length}...` 
                              : `ü§ñ Evaluate with LLM (${evalData.length} items)`
                            }
                          </button>
                          {isEvaluating && (
                            <button
                              onClick={() => { shouldStopRef.current = true; }}
                              className="bg-red-600 hover:bg-red-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                            >
                              ‚èπÔ∏è Stop
                            </button>
                          )}
                          <button
                            onClick={exportEvalResults}
                            disabled={evalResults.length === 0}
                            className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white px-6 py-3 rounded-lg font-semibold transition-colors"
                          >
                            üì• Export JSON
                          </button>
                        </div>

                        {evalResults.length > 0 && (
                          <div>
                            <h3 className="text-lg font-semibold mb-3 text-gray-800">
                              ü§ñ LLM Evaluation Results ({evalResults.length})
                            </h3>
                            <div className="space-y-4 max-h-[600px] overflow-y-auto">
                              {evalResults.map((r, i) => (
                                <div key={i} className="bg-gray-50 rounded-lg p-4 border">
                                  <div className="mb-3">
                                    <span className="text-xs font-semibold text-gray-500">
                                      ORIGINAL ({r.fromLang} ‚Üí {r.toLang}):
                                    </span>
                                    <div className="text-sm font-medium">{r.original}</div>
                                  </div>
                                  <div className="space-y-3">
                                    {Object.entries(r.evaluations).map(([model, metrics]) => {
                                      const isReference = model.includes('Reference');
                                      return (
                                      <div key={model} className={`p-4 rounded border ${isReference ? 'bg-purple-50 border-purple-300' : 'bg-white'}`}>
                                        <div className={`text-xs font-semibold mb-2 ${isReference ? 'text-purple-700' : 'text-blue-600'}`}>
                                          {model}
                                        </div>
                                        <div className="text-sm mb-3 text-gray-800 italic">
                                          "{metrics.translation}"
                                        </div>
                                        
                                        {/* Total Score and COMET-QE */}
                                        {(metrics.total !== undefined && metrics.total !== 'N/A') && (
                                        <div className="grid grid-cols-2 gap-2 mb-3">
                                          <div 
                                            className={`p-3 rounded-lg text-center border-2 border-purple-400 ${getMetricColorClass('total', metrics.total)}`}
                                            title={metricDescriptions.total}
                                          >
                                            <div className="text-xs font-semibold mb-1">‚≠ê TOTAL</div>
                                            <div className="text-2xl font-bold">{metrics.total}</div>
                                          </div>
                                          {metrics.cometQE !== undefined && metrics.cometQE !== 'N/A' && (
                                          <div 
                                            className={`p-3 rounded-lg text-center border ${getMetricColorClass('cometQE', metrics.cometQE)}`}
                                            title={metricDescriptions.cometQE}
                                          >
                                            <div className="text-xs font-semibold mb-1">üî∑ COMET-QE ‚Üë</div>
                                            <div className="text-2xl font-bold">{metrics.cometQE}</div>
                                          </div>
                                          )}
                                        </div>
                                        )}
                                        
                                        {/* LLM Scores - only if available */}
                                        {(metrics.score || metrics.fluency || metrics.adequacy) && (
                                        <div className="grid grid-cols-3 gap-2 mb-3">
                                          {metrics.score && (
                                          <div 
                                            className={`p-3 rounded-lg text-center border ${getMetricColorClass('score', metrics.score)}`}
                                            title="Overall Quality Score - Higher is better (Excellent: >8.5, Good: >7.0)"
                                          >
                                            <div className="text-xs font-semibold mb-1">Overall ‚Üë</div>
                                            <div className="text-2xl font-bold">{metrics.score}</div>
                                            <div className="text-xs">/ 10</div>
                                          </div>
                                          )}
                                          {metrics.fluency && (
                                          <div 
                                            className={`p-3 rounded-lg text-center border ${getMetricColorClass('fluency', metrics.fluency)}`}
                                            title="Fluency Score - Higher is better (Excellent: >8.5, Good: >7.0)"
                                          >
                                            <div className="text-xs font-semibold mb-1">Fluency ‚Üë</div>
                                            <div className="text-2xl font-bold">{metrics.fluency}</div>
                                            <div className="text-xs">/ 10</div>
                                          </div>
                                          )}
                                          {metrics.adequacy && (
                                          <div 
                                            className={`p-3 rounded-lg text-center border ${getMetricColorClass('adequacy', metrics.adequacy)}`}
                                            title="Adequacy Score - Higher is better (Excellent: >8.5, Good: >7.0)"
                                          >
                                            <div className="text-xs font-semibold mb-1">Adequacy ‚Üë</div>
                                            <div className="text-2xl font-bold">{metrics.adequacy}</div>
                                            <div className="text-xs">/ 10</div>
                                          </div>
                                          )}
                                        </div>
                                        )}
                                        
                                        {/* Feedback */}
                                        {metrics.feedback && (
                                          <div className="bg-gray-50 p-3 rounded border border-gray-200 mb-3">
                                            <div className="text-xs font-semibold text-gray-600 mb-1">Feedback:</div>
                                            <div className="text-xs text-gray-700">{metrics.feedback}</div>
                                          </div>
                                        )}
                                        
                                        {/* Basic Metrics - only if available */}
                                        {(metrics.lengthRatio !== undefined || metrics.jaccard !== undefined || 
                                          metrics.charCount !== undefined || metrics.wordCount !== undefined ||
                                          metrics.repetition !== undefined || metrics.numberPres !== undefined ||
                                          metrics.copyRate !== undefined) && (
                                        <div className="grid grid-cols-4 gap-2 text-xs">
                                          {metrics.repetition !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${getMetricColorClass('repetition', metrics.repetition)}`}
                                            title={metricDescriptions.repetition}
                                          >
                                            <div className="font-semibold">üîÅ Repeat ‚Üì</div>
                                            <div className="font-bold">{metrics.repetition}%</div>
                                          </div>
                                          )}
                                          {metrics.numberPres !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${getMetricColorClass('numberPres', metrics.numberPres)}`}
                                            title={metricDescriptions.numberPres}
                                          >
                                            <div className="font-semibold">üî¢ Numbers ‚Üë</div>
                                            <div className="font-bold">{metrics.numberPres}%</div>
                                          </div>
                                          )}
                                          {metrics.copyRate !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${getMetricColorClass('copyRate', metrics.copyRate)}`}
                                            title={metricDescriptions.copyRate}
                                          >
                                            <div className="font-semibold">üìã Copy</div>
                                            <div className="font-bold">{metrics.copyRate}%</div>
                                          </div>
                                          )}
                                          {metrics.sentMatch !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${metrics.sentMatch === '‚úì' ? 'bg-green-100' : 'bg-yellow-100'}`}
                                            title={`Sentence count: Original ${metrics.sentOrig} / Translation ${metrics.sentTrans}`}
                                          >
                                            <div className="font-semibold">üìù Sent</div>
                                            <div className="font-bold">{metrics.sentOrig}/{metrics.sentTrans} {metrics.sentMatch}</div>
                                          </div>
                                          )}
                                          {metrics.lengthRatio !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${getMetricColorClass('lengthRatio', metrics.lengthRatio)}`}
                                            title="Length Ratio - Optimal at 100% (Excellent: 90-110%, Good: 80-120%)"
                                          >
                                            <div className="font-semibold">Len% ‚âà100</div>
                                            <div className="font-bold">{metrics.lengthRatio}%</div>
                                          </div>
                                          )}
                                          {metrics.jaccard !== undefined && (
                                          <div 
                                            className={`p-2 rounded text-center ${getMetricColorClass('jaccard', metrics.jaccard)}`}
                                            title="Jaccard Similarity - Higher is better (Excellent: >75%, Good: >60%)"
                                          >
                                            <div className="font-semibold">Jaccard ‚Üë</div>
                                            <div className="font-bold">{metrics.jaccard}%</div>
                                          </div>
                                          )}
                                          {metrics.charCount !== undefined && (
                                          <div className="bg-indigo-50 p-2 rounded text-center border border-indigo-200">
                                            <div className="font-semibold text-indigo-700">Chars</div>
                                            <div className="font-bold">{metrics.charCount}</div>
                                          </div>
                                          )}
                                          {metrics.wordCount !== undefined && (
                                          <div className="bg-pink-50 p-2 rounded text-center border border-pink-200">
                                            <div className="font-semibold text-pink-700">Words</div>
                                            <div className="font-bold">{metrics.wordCount}</div>
                                          </div>
                                          )}
                                        </div>
                                        )}
                                      </div>
                                    );
                                    })}
                                  </div>
                                </div>
                              ))}
                            </div>
                            
                            {/* Statistics Summary for LLM Judge */}
                            {(() => {
                              const stats = calculateStatistics();
                              if (!stats) return null;
                              
                              // Include Reference in statistics (it now has all metrics)
                              const models = Object.keys(stats);
                              if (models.length === 0) return null;
                              
                              const metrics = ['total', 'score', 'fluency', 'adequacy', 'cometQE', 'repetition', 'numberPres', 'copyRate', 'lengthRatio', 'jaccard'];
                              const availableMetrics = metrics.filter(m => 
                                models.some(model => stats[model][m] !== undefined)
                              );
                              
                              if (availableMetrics.length === 0) return null;
                              
                              // Chart metrics for visual comparison
                              const chartMetrics = ['total', 'score', 'cometQE', 'repetition', 'numberPres'].filter(m => 
                                models.some(model => stats[model][m] !== undefined)
                              );
                              
                              // Colors for different models
                              const modelColors = [
                                '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', 
                                '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
                              ];
                              
                              return (
                                <div className="mt-6 border-t-2 pt-6">
                                  <h3 className="text-xl font-bold mb-4 text-gray-800">
                                    üìà Overall Statistics (Averages Across All Texts)
                                  </h3>
                                  
                                  {/* Summary Table */}
                                  <div className="bg-white rounded-lg border-2 overflow-hidden mb-6">
                                    <table className="w-full text-sm">
                                      <thead className="bg-gray-100">
                                        <tr>
                                          <th className="px-4 py-3 text-left font-bold text-gray-700">Model</th>
                                          {availableMetrics.map(metric => (
                                            <th key={metric} className="px-4 py-3 text-center font-bold text-gray-700">
                                              {metricsInfo[metric]?.name || metric}
                                              <div className="text-xs font-normal text-gray-500">
                                                {metricsInfo[metric]?.description || ''}
                                              </div>
                                            </th>
                                          ))}
                                        </tr>
                                      </thead>
                                      <tbody>
                                        {models.map((model, idx) => {
                                          const isReference = model.includes('Reference');
                                          return (
                                            <tr key={model} className={isReference ? 'bg-purple-50' : (idx % 2 === 0 ? 'bg-white' : 'bg-gray-50')}>
                                              <td className={`px-4 py-3 font-semibold ${isReference ? 'text-purple-700' : 'text-blue-700'}`}>
                                                {model}
                                              </td>
                                              {availableMetrics.map(metric => {
                                                const value = stats[model][metric];
                                                const std = stats[model][metric + '_std'];
                                                const min = stats[model][metric + '_min'];
                                                const max = stats[model][metric + '_max'];
                                                const suffix = (metric === 'lengthRatio' || metric === 'jaccard' || metric === 'repetition' || metric === 'numberPres' || metric === 'copyRate') ? '%' : '';
                                                return (
                                                  <td key={metric} className="px-4 py-3 text-center">
                                                    {value !== undefined ? (
                                                      <div className="flex flex-col items-center">
                                                        <span className={`inline-block px-3 py-1 rounded font-bold ${getMetricColorClass(metric, value)}`}>
                                                          {value}{suffix}
                                                        </span>
                                                        {std && parseFloat(std) > 0 && (
                                                          <span className="text-xs text-gray-500 mt-0.5" title={`Min: ${min}${suffix}, Max: ${max}${suffix}`}>
                                                            ¬±{std}
                                                          </span>
                                                        )}
                                                      </div>
                                                    ) : (
                                                      <span className="text-gray-400">‚Äî</span>
                                                    )}
                                                  </td>
                                                );
                                              })}
                                            </tr>
                                          );
                                        })}
                                      </tbody>
                                    </table>
                                  </div>
                                  
                                  {/* Time & Cost Summary */}
                                  {(() => {
                                    const hasTimeCost = models.some(m => 
                                      stats[m].time !== undefined || stats[m].cost_total !== undefined
                                    );
                                    if (!hasTimeCost) return null;
                                    
                                    return (
                                      <div className="bg-gradient-to-r from-purple-50 to-pink-50 p-4 rounded-lg border-2 border-purple-200 mb-6">
                                        <h4 className="font-bold text-purple-900 mb-3">‚è±Ô∏è Time & üí∞ Cost Summary</h4>
                                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                                          {models.map(model => {
                                            const time = stats[model].time_total;
                                            const cost = stats[model].cost_total;
                                            if (!time && !cost) return null;
                                            
                                            return (
                                              <div key={model} className="bg-white p-3 rounded-lg border">
                                                <div className="font-semibold text-sm text-gray-800 mb-2 truncate" title={model}>
                                                  {model.length > 30 ? model.substring(0, 28) + '...' : model}
                                                </div>
                                                <div className="space-y-1 text-xs">
                                                  {time && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-600">Total Time:</span>
                                                      <span className="font-bold text-blue-700">{time}s</span>
                                                    </div>
                                                  )}
                                                  {cost && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-600">Total Cost:</span>
                                                      <span className="font-bold text-green-700">${cost}</span>
                                                    </div>
                                                  )}
                                                  {stats[model].time && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-500">Avg Time:</span>
                                                      <span className="text-gray-700">{stats[model].time}s</span>
                                                    </div>
                                                  )}
                                                  {stats[model].cost && (
                                                    <div className="flex justify-between">
                                                      <span className="text-gray-500">Avg Cost:</span>
                                                      <span className="text-gray-700">${stats[model].cost}</span>
                                                    </div>
                                                  )}
                                                </div>
                                              </div>
                                            );
                                          })}
                                        </div>
                                      </div>
                                    );
                                  })()}
                                  
                                  
                                  {/* Advanced Analytics */}
                                  <div className="mt-8 border-t-4 border-orange-400 pt-6">
                                    <h3 className="text-2xl font-bold mb-6 text-orange-900 flex items-center gap-2">
                                      üìä Advanced Analytics
                                    </h3>
                                    
                                    {(() => {
                                      // Prepare data for all charts
                                      const companyColors = {
                                        'Anthropic': '#D97706', 'OpenAI': '#10B981', 'DeepSeek': '#3B82F6',
                                        'DeepL': '#0052CC', 'Google': '#EA4335', 'Meta': '#1877F2',
                                        'Helsinki-NLP': '#FF6B35', 'Open Source': '#6B7280', 'Human': '#9333EA'
                                      };
                                      
                                      const chartData = models
                                        .filter(m => stats[m].total !== undefined)
                                        .map(model => {
                                          const meta = getModelMeta(model);
                                          const releaseDate = meta.released ? new Date(meta.released) : null;
                                          return {
                                            model,
                                            quality: parseFloat(stats[model].total) || 0,
                                            cost: parseFloat(stats[model].cost_total) || 0,
                                            pricePerMToken: meta.priceOut || 0,
                                            time: parseFloat(stats[model].time) || 0,
                                            releasedYear: releaseDate ? releaseDate.getFullYear() + (releaseDate.getMonth() / 12) : null,
                                            company: meta.company,
                                            sizeB: meta.sizeB,
                                            perPair: meta.perPair || false,
                                            isReference: model.includes('Reference')
                                          };
                                        });
                                      
                                      return (
                                        <>
                                          {/* Model Ranking Table */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-orange-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-4">üèÜ Model Ranking</h4>
                                            <table className="w-full text-sm">
                                              <thead><tr className="border-b-2"><th className="text-left py-2 w-12">#</th><th className="text-left py-2">Model</th><th className="text-left py-2">Company</th><th className="text-right py-2">Quality</th></tr></thead>
                                              <tbody>
                                                {[...chartData].sort((a,b) => b.quality - a.quality).map((d, idx) => (
                                                  <tr key={d.model} className={`border-b ${d.isReference ? 'bg-purple-50' : ''}`}>
                                                    <td className="py-2 font-bold text-center">{idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : idx === 2 ? 'ü•â' : idx+1}</td>
                                                    <td className={`py-2 ${d.isReference ? 'text-purple-700 font-bold' : ''}`}>{d.model}</td>
                                                    <td className="py-2 text-gray-600">{d.company}</td>
                                                    <td className="py-2 text-right font-bold" style={{color: d.isReference ? '#9333EA' : companyColors[d.company]}}>{d.quality.toFixed(1)}</td>
                                                  </tr>
                                                ))}
                                              </tbody>
                                            </table>
                                          </div>
                                          
                                          {/* Quality vs Price XY */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-green-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üí∞ Quality vs Price</h4>
                                            <p className="text-sm text-gray-500 mb-4">Higher & more left = better value. Price per 1M output tokens.</p>
                                            <ScatterPlot data={chartData.filter(d => !d.isReference)} xKey="pricePerMToken" xLabel="Price per 1M tokens ($)" yLabel="Quality Score" title="Quality vs Price" xFormat={v => v === 0 ? 'FREE' : '$'+v.toFixed(2)}/>
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center text-xs">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k)).map(([c, col]) => <span key={c} className="flex items-center gap-1"><span className="w-3 h-3 rounded-full" style={{backgroundColor:col}}></span>{c}</span>)}
                                            </div>
                                          </div>
                                          
                                          {/* Quality vs Speed XY */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-blue-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">‚ö° Quality vs Speed</h4>
                                            <p className="text-sm text-gray-500 mb-4">Higher & more left = faster with good quality</p>
                                            <ScatterPlot data={chartData.filter(d => !d.isReference)} xKey="time" xLabel="Avg Time (seconds)" yLabel="Quality Score" title="Quality vs Time" xFormat={v => v.toFixed(1)+'s'}/>
                                          </div>
                                          
                                          {/* Quality vs Release Date XY */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-purple-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üìÖ Quality vs Release Date</h4>
                                            <p className="text-sm text-gray-500 mb-4">Are newer models better? Right = newer</p>
                                            <ScatterPlot data={chartData.filter(d => d.releasedYear !== null)} xKey="releasedYear" xLabel="Release Year" yLabel="Quality Score" title="Model Evolution Over Time" xFormat={v => Math.floor(v).toString()}/>
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center text-xs">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k)).map(([c, col]) => <span key={c} className="flex items-center gap-1"><span className="w-3 h-3 rounded-full" style={{backgroundColor:col}}></span>{c}</span>)}
                                            </div>
                                          </div>
                                          
                                          {/* Quality vs Model Size XY */}
                                          <div className="bg-white p-6 rounded-xl border-2 border-orange-200 mb-6 shadow-sm">
                                            <h4 className="text-lg font-bold text-gray-800 mb-2">üìê Quality vs Model Size</h4>
                                            <p className="text-sm text-gray-500 mb-4">Does size matter? X = model parameters, log scale (Argos/OPUS-MT sizes are per language pair)</p>
                                            <ScatterPlot data={chartData.filter(d => d.sizeB && d.sizeB > 0)} xKey="sizeB" xLabel="Model Size (Billion params)" yLabel="Quality Score" title="Quality vs Model Size" xFormat={v => v >= 1000 ? (v/1000).toFixed(1)+'T' : v >= 1 ? v.toFixed(0)+'B' : (v*1000).toFixed(0)+'M'} logScale={true}/>
                                            <div className="flex flex-wrap gap-3 mt-4 justify-center text-xs">
                                              {Object.entries(companyColors).filter(([k]) => chartData.some(d => d.company === k && d.sizeB > 0)).map(([c, col]) => <span key={c} className="flex items-center gap-1"><span className="w-3 h-3 rounded-full" style={{backgroundColor:col}}></span>{c}</span>)}
                                            </div>
                                          </div>
                                          
                                          {/* Quick Insights */}
                                          <div className="bg-gradient-to-r from-orange-50 to-amber-50 p-6 rounded-xl border-2 border-orange-300">
                                            <h4 className="text-lg font-bold text-orange-900 mb-4">üìã Quick Insights</h4>
                                            {(() => {
                                              const nonRef = chartData.filter(d => !d.isReference);
                                              if (nonRef.length === 0) return <p className="text-gray-500">No data</p>;
                                              const best = nonRef.reduce((a,b) => a.quality > b.quality ? a : b);
                                              const fastest = nonRef.filter(d => d.time > 0).length > 0 ? nonRef.filter(d => d.time > 0).reduce((a,b) => a.time < b.time ? a : b) : null;
                                              const paidModels = nonRef.filter(d => d.pricePerMToken > 0);
                                              const cheapest = paidModels.length > 0 ? paidModels.reduce((a,b) => a.pricePerMToken < b.pricePerMToken ? a : b) : null;
                                              return (
                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                                                  <div className="bg-white p-3 rounded-lg"><span className="text-2xl">üèÜ</span> <strong>Best:</strong> {best.model} ({best.quality.toFixed(1)})</div>
                                                  {fastest && <div className="bg-white p-3 rounded-lg"><span className="text-2xl">‚ö°</span> <strong>Fastest:</strong> {fastest.model} ({fastest.time.toFixed(1)}s)</div>}
                                                  {cheapest && <div className="bg-white p-3 rounded-lg"><span className="text-2xl">üí∞</span> <strong>Cheapest:</strong> {cheapest.model} (${cheapest.pricePerMToken}/1M)</div>}
                                                </div>
                                              );
                                            })()}
                                          </div>
                                        </>
                                      );
                                    })()}
                                  </div>

                                </div>
                              );
                            })()}
                          </div>
                        )}
                      </>
                    )}
                  </div>
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
